/**
* Generated by PluginGenerator from webgme on Tue Jun 10 2014 17:42:32 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/C2MF/C2MF/meta'], function (PluginConfig, PluginBase, MetaTypes) {
    'use strict';

    /**
    * Initializes a new instance of C2MF.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin C2MF.
    * @constructor
    */
    var C2MF = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
    };

    // Prototypal inheritance from PluginBase.
    C2MF.prototype = Object.create(PluginBase.prototype);
    C2MF.prototype.constructor = C2MF;

    /**
    * Gets the name of the C2MF.
    * @returns {string} The name of the plugin.
    * @public
    */
    C2MF.prototype.getName = function () {
        return "Component2MatlabFile";
    };

    /**
    * Gets the semantic version (semver.org) of the C2MF.
    * @returns {string} The version of the plugin.
    * @public
    */
    C2MF.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the C2MF.
    * @returns {string} The description of the plugin.
    * @public
    */
    C2MF.prototype.getDescription = function () {
        return "Generate a Matlab m-file from a Component";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    C2MF.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            componentInfo,
            mFileString = '';

        self.updateMETA(self.metaTypes);

        componentInfo = self.getElementsAndConnections(self.activeNode);

        for (var id in componentInfo.elements) {
            var element = componentInfo.elements[id];
            for (var key in element) {
                var value = element[key];
                // add the (key, value) info to to the mFileString
            }
        }
    };

    C2MF.prototype.getElementsAndConnections = function (componentNode, errors, callback) {
        var self = this,
            childNode,
            metaNode,
            metaName,
            loadChildrenCallbackFunction,
            element,
            bond,
            elementCount = 0,
            bondCount = 0,
            componentInfo = {
                elements: {},
                bonds: {}
            };

        loadChildrenCallbackFunction = function (err, children) {
            if (err) {
                callback(err);
            }

            for (var i = 0; i < children.length; i += 1) {
                childNode = children[i];
                metaNode = self.getMetaType(childNode);
                metaName = self.core.getAttribute(metaNode, 'name');

                //if (metaNode === self.metaTypes.ComponentConnection) {
                if (self.isMetaTypeOf(childNode, self.metaTypes.ComponentConnection)) {
                    bondCount += 1;
                    bond = {
                        src: self.core.getPointerPath(childNode, 'src'),
                        dst: self.core.getPointerPath(childNode, 'dst')
                    };

                    componentInfo.bonds[bondCount] = bond;
                } else {
                    elementCount += 1;
                    element = {
                        ID: self.core.getPath(childNode),
                        Name: self.core.getAttribute(childNode, 'name'),
                        Type: metaName,
                        Equation: 'N/A',
                        Ratio: 0,
                        Bond: ''
                    };

                    if (metaNode === self.metaTypes.ControlPort ||
                        metaNode === self.metaTypes.ResistivePort ||
                        metaNode === self.metaTypes.StoragePort) {
                        element.Equation = self.core.getAttribute(childNode, 'Equation');
                    }
                    if (metaNode === self.metaTypes.Gyrator ||
                        metaNode === self.metaTypes.Transformer) {
                        element.Ratio = self.core.getAttribute(childNode, 'Ratio');
                    }

                    componentInfo.elements[elementCount] = element;
                }
            }

            return componentInfo;
        };

        self.core.loadChildren(componentNode, loadChildrenCallbackFunction);
    };

    return C2MF;
});