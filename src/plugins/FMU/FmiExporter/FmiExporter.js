/**
* Generated by PluginGenerator from webgme on Wed Apr 16 2014 16:05:02 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'ejs',
        'plugin/FmiExporter/FmiExporter/Templates/Templates'],
    function (PluginConfig, PluginBase, EJS, TEMPLATES) {
    'use strict';

    /**
    * Initializes a new instance of FmiExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin FmiExporter.
    * @constructor
    */
    var FmiExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.fmuIdToInfoMap = {};
        this.fmus = [];
        this.fmuPackageHashMap = {};
        this.connectionMap = {};
        this.connections = [];
        this.simulationInfo = {
            'StartTime': 0,
            'StopTime': 1,
            'StepSize': 0.001
        };
        this.modelExchangeConfig = {};
        this.filesToSave = {};

        // FIXME: this map should be exported from WebGME
        this.fmiMetaTypes = {
            'FMU': '/1822302751/902541625',
            'PortComposition': '/1822302751/472382791',
            'Input': '/1822302751/873609603',
            'Output': '/1822302751/206401000',
            'Parameter': '/1822302751/1582216564',
            'SimulationParameter': '/1822302751/1963127367',
            'ModelExchange': '/1822302751/637828452'
        };
    };

    // Prototype inheritance from PluginBase.
    FmiExporter.prototype = Object.create(PluginBase.prototype);
    FmiExporter.prototype.constructor = FmiExporter;

    if (!ejs) {
        ejs = EJS || window.ejs;
    }

    /**
    * Gets the name of the FmiExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    FmiExporter.prototype.getName = function () {
        return "FMI ModelExchange Exporter";
    };

    /**
    * Gets the description of the FmiExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    FmiExporter.prototype.getDescription = function () {
        return "Generates a model_exchange_config.json for simulating a FMI system";
    };

    /**
    * Gets the semantic version (semver.org) of the FmiExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    FmiExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always have to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    FmiExporter.prototype.main = function (callback) {
        var self = this,
            selectedNode = self.activeNode,
            selectedNodeBaseType = self.getMetaType(selectedNode),
            selectedNodeBasePath = self.core.getPath(selectedNodeBaseType),
            modelExchangeName = self.core.getAttribute(selectedNode, 'name'),
            modelExchangeNode;

        if (!selectedNode) {
            callback('selectedNode is not defined', self.result);
            return;
        }

        if (selectedNodeBasePath != self.fmiMetaTypes.ModelExchange) {
            callback('SelectedNode is not a ModelExchange!', self.result);
        } else {
            modelExchangeNode = selectedNode;
        }

        // core.loadChildren returns err and childNodes
        var loadModelExchangeChildrenCallbackFunction = function (err, childNodes) {
            if (err) {
                self.logger.error('Something went wrong getting child nodes');
                callback('Something went wrong getting child nodes', self.result);
                return;
            }

            var extractMeConfigInfoCallback = function (err) {

                if (err) {
                    self.result.setSuccess(false);
                    callback(err, self.result);
                    return;
                }

                self.assignPriorityAndFlatten();

                var artifact = self.blobClient.createArtifact(modelExchangeName);

                self.modelExchangeConfig['Connections'] = self.connections;
                self.modelExchangeConfig['FMUs'] = self.fmus;
                self.modelExchangeConfig['SimulationInfo'] = self.simulationInfo;
                var fileInfo = JSON.stringify(self.modelExchangeConfig, null, 4);

                var tt1 = ejs.render(TEMPLATES['fmi_wrapper.py.ejs']);
                var tt2 = ejs.render(TEMPLATES['jmodelica_model_exchange.py.ejs']);
                var tt3 = ejs.render(TEMPLATES['run_jmodelica_model_exchange.cmd.ejs']);

                self.filesToSave['model_exchange_config.json'] = fileInfo;
                self.filesToSave['fmi_wrapper.py'] = tt1;
                self.filesToSave['jmodelica_model_exchange.py'] = tt2;
                self.filesToSave['run_jmodelica_model_exchange.cmd'] = tt3;

                var addFilesCallback = function (err, fileHashes) {
                    if (err) {
                        self.result.setSuccess(false);
                        callback(err, self.result);
                        return;
                    }

                    self.logger.info('Generated file hashes: ' + fileHashes);

//                    var i,
//                        fmuPackageName,
//                        fmuHash,
//                        fmuPackageHashMapKeys = Object.keys(self.fmuPackageHashMap);
//
//                    for (i = 0; i < fmuPackageHashMapKeys.length; i += 1) {
//                        fmuPackageName = fmuPackageHashMapKeys[i],
//                        fmuHash = self.fmuPackageHashMap[fmuPackageName];
//                        artifact.addHash(fmuPackageName + ".fmu", fmuHash);
//                    }

                    // FIXME: in case you use only a single artifact then artifact.save(function(err, hash) {...
                    //        can be used
                    //artifact.save(function (err, artifactHash) {
                    self.blobClient.saveAllArtifacts(function (err, artifactHashes) {
                        // FIXME: error handling

                        //self.logger.info('Saved artifact hashes are: ' + artifactHash);
                        self.logger.info('Saved artifact hashes are: ' + artifactHashes[0]);

                        //self.result.addArtifact(artifactHash);
                        self.result.addArtifact(artifactHashes[0]);

                        self.result.setSuccess(true);

                        // This will save the changes. If you don't want to save;
                        // exclude self.save and call callback directly from this scope.
                        self.save('Finished FmiExporter', function (err) {
                            // FIXME: error handling

                            callback(null, self.result);
                        });
                    });
                };

                artifact.addFiles(self.filesToSave, addFilesCallback);
            };

            self.extractModelExchangeConfigInfo(childNodes, extractMeConfigInfoCallback);
        };

        self.core.loadChildren(modelExchangeNode, loadModelExchangeChildrenCallbackFunction);
    };

    // An asynchronous function to iterate over the ModelExchange children and extract info
    FmiExporter.prototype.extractModelExchangeConfigInfo = function (modelExchangeChildren, callback) {
        var self = this,
            i,
            meChildNode,
            meChildName,
            baseTypeNode,
            baseTypePath,
            counter = modelExchangeChildren.length,
            error = '';

        var iterationCallback = function (err) {
            if (err) {
                error += err;
            }

            counter -= 1;

            if (counter === 0) {
                callback(error);
            }
        };

        var loadFmuChildrenCallbackFunction = function (loadChildrenErr, fmuChildren) {
            var fmuNode = self.core.getParent(fmuChildren[0]),
                relid = self.core.getRelid(fmuNode),
                fmuInfo;

            fmuInfo = self.extractFmuInfo(fmuChildren);

            fmuInfo['Name'] = self.core.getAttribute(fmuNode, 'name');
            fmuInfo['File'] = self.core.getAttribute(fmuNode, 'fmu_path');
            fmuInfo['Asset'] = self.core.getAttribute(fmuNode, 'resource');
            fmuInfo['Priority'] = 1;

            self.fmuIdToInfoMap[relid] = fmuInfo;

            iterationCallback(loadChildrenErr);
        };

        for (i = 0; i < modelExchangeChildren.length; i += 1) {

            meChildNode = modelExchangeChildren[i];
            baseTypeNode = self.getMetaType(meChildNode);
            baseTypePath = self.core.getPath(baseTypeNode);

            // FIXME: this condition is fine now, but will not work correctly if we have a more complicated inheritance
            //        in the meta model.
            if (baseTypePath === self.fmiMetaTypes.PortComposition) {

                var srcPath = self.core.getPointerPath(meChildNode, 'src'),
                    dstPath = self.core.getPointerPath(meChildNode, 'dst'),
                    srcIds = srcPath.split('/').slice(-2).join('/'), // FIXME: extract this as a (synchronous) function
                    dstIds = dstPath.split('/').slice(-2).join('/'); // FIXME: extract this as a (synchronous) function

                if (self.connectionMap.hasOwnProperty(srcIds)) {
                    self.connectionMap[srcIds].push(dstIds);

                } else {
                    self.connectionMap[srcIds] = [dstIds];
                }

                iterationCallback(null);

            } else if (baseTypePath === self.fmiMetaTypes.FMU) {
                // asynchronous call to get parameter and port information
                self.core.loadChildren(meChildNode, loadFmuChildrenCallbackFunction);

            } else if (baseTypePath === self.fmiMetaTypes.SimulationParameter) {
                meChildName = self.core.getAttribute(meChildNode, 'name');

                if (self.simulationInfo.hasOwnProperty(meChildName)) {
                    self.simulationInfo[meChildName] = self.core.getAttribute(meChildNode, 'value');
                }

                iterationCallback(null);
            }

        }
    };

    FmiExporter.prototype.assignPriorityAndFlatten = function () {

        var self = this,
            fmuMapKeys = Object.keys(self.fmuIdToInfoMap),
            connMapKeys = Object.keys(self.connectionMap),
            connMapKey,
            fmuId,
            fmu,
            fmuHash,
            fmuPriority,
            i;

        for (i = 0; i < fmuMapKeys.length; i += 1) {
            fmuId = fmuMapKeys[i],
            fmu = self.fmuIdToInfoMap[fmuId],
            fmuHash = fmu.Asset,
            fmuPriority = fmu.Priority;

            if (fmuPriority === 1) {
                self.followConnsAssignPriority(fmuId, fmu);
            }

            self.fmuPackageHashMap[fmu.Name] = fmuHash;
            self.fmus.push(fmu);
        }

        var splitKey,
            srcFmu,
            srcPriority,
            srcFmuId,
            srcFmuName,
            srcPortId,
            srcPortName,
            dstConnections,
            dstConnIds,
            splitIds,
            dstFmu,
            dstPriority,
            dstFmuId,
            dstFmuName,
            dstPortId,
            dstPortName,
            flatConnInfo,
            j;

        for (i = 0; i < connMapKeys.length; i += 1) {
            connMapKey = connMapKeys[i];
            splitKey = connMapKey.split('/');
            srcFmuId = splitKey[0];
            srcPortId = splitKey[1];
            srcFmu = self.fmuIdToInfoMap[srcFmuId];
            srcFmuName = srcFmu.Name;
            srcPriority = srcFmu.Priority;
            srcPortName = srcFmu.OutputMap[srcPortId];
            dstConnections = self.connectionMap[connMapKey];

            for (j = 0; j < dstConnections.length; j += 1) {
                dstConnIds = dstConnections[j];
                splitIds = dstConnIds.split('/');
                dstFmuId = splitIds[0];
                dstPortId = splitIds[1];
                dstFmu = self.fmuIdToInfoMap[dstFmuId];
                dstFmuName = dstFmu.Name;
                dstPriority = dstFmu.Priority;
                dstPortName = dstFmu.InputMap[dstPortId];

                flatConnInfo = {
                    'Source': srcFmuName + '.' + srcPortName,
                    'Destination': dstFmuName + '.' + dstPortName,
                    'SrcPriority': srcPriority,
                    'DstPriority': dstPriority
                };

                self.connections.push(flatConnInfo);
            }
        }
    };

    FmiExporter.prototype.followConnsAssignPriority = function (srcFmuId, srcFmu) {
        var self = this,
            srcFmuName = srcFmu.Name,
            srcFmuOutputs = srcFmu.OutputMap,
            outputIds = Object.keys(srcFmuOutputs),
            srcPriority = srcFmu.Priority,
            dstPriority = srcPriority + 1,
            numberOutputs = outputIds.length,
            i,
            j;

        if (numberOutputs === 0) {
            self.logger.debug(srcFmu.Name + " has no Outputs.");
            return;
        }

        for (i = 0; i < outputIds.length; i += 1) {
            var outputId = outputIds[i],
                outputName = srcFmuOutputs[outputId],
                connMapKey = srcFmuId + '/' + outputId;

            if (self.connectionMap.hasOwnProperty(connMapKey) === false) {
                self.logger.debug("No connections leaving from " + srcFmuName + "." + outputName);
                continue;
            }

            // Could be multiple connections leaving this port
            var allConnections = self.connectionMap[connMapKey];

            for (j = 0; j < allConnections.length; j += 1) {
                var connectedInput = allConnections[j],
                    dstFmuId = connectedInput.split("/")[0],
                    dstPortId = connectedInput.split("/")[1],
                    dstFmu = self.fmuIdToInfoMap[dstFmuId],
                    dstPortName = dstFmu.InputMap[dstPortId];

                if (dstFmu.Priority < dstPriority) {
                    dstFmu.Priority = dstPriority;
                }

                // dst becomes src, repeat
                self.followConnsAssignPriority(dstFmuId, dstFmu);
            }
        }
    };

    // a Synchronous helper function to get FMU Parameters, Inputs, and Outputs
    FmiExporter.prototype.extractFmuInfo = function (fmuChildren) {
        var self = this,
            i,
            fmuChildNode,
            fmuChildNodeRelid,
            fmuChildNodeName,
            baseTypeNode,
            baseTypePath,
            parameters = {},
            inputMap = {},
            outputMap = {},
            inputs = [],
            outputs = [],
            fmuInfo = {};

        for (i = 0; i < fmuChildren.length; i += 1) {

            fmuChildNode = fmuChildren[i];
            fmuChildNodeRelid = self.core.getRelid(fmuChildNode); // FIXME: getPath?
            fmuChildNodeName = self.core.getAttribute(fmuChildNode, 'name');
            baseTypeNode = self.getMetaType(fmuChildNode);
            baseTypePath = self.core.getPath(baseTypeNode);

            if (baseTypePath === self.fmiMetaTypes.Parameter) {
                parameters[fmuChildNodeName] = self.core.getAttribute(fmuChildNode, 'value');

            } else if (baseTypePath === self.fmiMetaTypes.Input) {
                inputMap[fmuChildNodeRelid] = fmuChildNodeName;
                inputs.push(fmuChildNodeName);

            } else if (baseTypePath === self.fmiMetaTypes.Output) {
                outputMap[fmuChildNodeRelid] = fmuChildNodeName;
                outputs.push(fmuChildNodeName);
            }
        }

        fmuInfo['Parameters'] = parameters;
        fmuInfo['Inputs'] = inputs;
        fmuInfo['InputMap'] = inputMap;
        fmuInfo['Outputs'] = outputs;
        fmuInfo['OutputMap'] = outputMap;

        return fmuInfo;
    };

    /**
    * Checks if the given node is of the given meta-type.
    * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>
    * @param node - Node to be check for type.
    * @param metaTypeObj - Node object defining the meta type.
    * @returns {boolean} - True if the given object was of the META type.
    */
    FmiExporter.prototype.isMetaTypeOf = function (node, metaTypeObj) {
        var self = this;
        while (node) {
            if (self.core.getGuid(node) === self.core.getGuid(metaTypeObj)) {
                return true;
            }
            node = self.core.getBase(node);
        }
        return false;
    };

    /**
    * Finds and returns the node object defining the meta type for the given node.
    * @param node - Node to be check for type.
    * @returns {Object} - Node object defining the meta type of node.
    */
    FmiExporter.prototype.getMetaType = function (node) {
        var self = this,
            name;
        while (node) {
            name = self.core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                break;
            }
            node = self.core.getBase(node);
        }
        return node;
    };

    return FmiExporter;
});

