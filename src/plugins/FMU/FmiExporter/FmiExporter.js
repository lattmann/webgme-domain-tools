/**
* Generated by PluginGenerator from webgme on Wed Apr 16 2014 16:05:02 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/FmiExporter/FmiExporter/FMU',
        'plugin/FmiExporter/FmiExporter/Templates/Templates',
        'ejs'], function (PluginConfig, PluginBase, FmuMetaTypes, ejs, TEMPLATES) {
    // PM: This change saves you one indent (or JSLint complaints for each method).
    'use strict';

    /**
    * Initializes a new instance of FmiExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin FmiExporter.
    * @constructor
    */
    var FmiExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.fmuIdToInfoMap = {};
        this.fmus = [];
        this.fmuPackageHashMap = {};
        this.connectionMap = {};
        this.connections = [];
        this.simulationInfo = {
            'StartTime': 0,
            'StopTime': 1,
            'StepSize': 0.001
        };
        this.modelExchangeConfig = {};
        this.filesToSave = {};
    };

    // Prototype inheritance from PluginBase.
    FmiExporter.prototype = Object.create(PluginBase.prototype);
    FmiExporter.prototype.constructor = FmiExporter;

    /**
    * Gets the name of the FmiExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    FmiExporter.prototype.getName = function () {
        return "FMI ModelExchange Exporter";
    };

    /**
    * Gets the description of the FmiExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    FmiExporter.prototype.getDescription = function () {
        return "Generates a model_exchange_config.json for simulating a FMI system";
    };

    /**
    * Gets the semantic version (semver.org) of the FmiExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    FmiExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always have to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    FmiExporter.prototype.main = function (callback) {
        var self = this,
            selectedNode = self.activeNode,
            modelExchangeName = self.core.getAttribute(selectedNode, 'name'),
            modelExchangeNode;

        if (!selectedNode) {
            callback('selectedNode is not defined', self.result);
            return;
        }

        this.updateMETA(FmuMetaTypes);

        if (self.isMetaTypeOf(selectedNode, FmuMetaTypes.ModelExchange)) {
            modelExchangeNode = selectedNode;
        } else {
            callback('SelectedNode is not a ModelExchange!', self.result);
            return;
        }

        var loadModelExchangeChildrenCallbackFunction = function (err, childNodes) {
            if (err) {
                var msg = "Something went wrong getting child nodes";
                self.logger.error(msg);
                callback(msg, self.result);
                return;
            }

            var extractMeConfigInfoCallback = function (err) {
                if (err) {
                    self.result.setSuccess(false);
                    callback(err, self.result);
                    return;
                }

                //self.assignPriorityAndFlatten();
                self.runTarjans();

                var artifact = self.blobClient.createArtifact(modelExchangeName);

                self.modelExchangeConfig['Connections'] = self.connections;
                self.modelExchangeConfig['FMUs'] = self.fmus;
                self.modelExchangeConfig['SimulationInfo'] = self.simulationInfo;
                var fileInfo = JSON.stringify(self.modelExchangeConfig, null, 4);

                var tt1 = ejs.render(TEMPLATES['fmi_wrapper.py.ejs']);
                var tt2 = ejs.render(TEMPLATES['jmodelica_model_exchange.py.ejs']);
                var tt3 = ejs.render(TEMPLATES['run_jmodelica_model_exchange.cmd.ejs']);
                var tt4 = ejs.render(TEMPLATES['ReadMe.txt.ejs']);

                self.filesToSave['model_exchange_config.json'] = fileInfo;
                self.filesToSave['fmi_wrapper.py'] = tt1;
                self.filesToSave['jmodelica_model_exchange.py'] = tt2;
                self.filesToSave['run_jmodelica_model_exchange.cmd'] = tt3;
                self.filesToSave['ReadMe.txt'] = tt4;

                var addFilesCallback = function (err, fileHashes) {
                    if (err) {
                        self.result.setSuccess(false);
                        callback(err, self.result);
                        return;
                    }

                    var i,
                        fmuPackageName,
                        fmuPathWithinArtifact,
                        fmuHash,
                        fmuPackageHashMapKeys = Object.keys(self.fmuPackageHashMap),
                        addHashesError,
                        addHashesCounter = fmuPackageHashMapKeys.length;

                    var addHashCounterCallback = function (addHashCallbackError, addedHash) {
                        if (addHashCallbackError) {
                            addHashesError += addHashCallbackError;
                        }

                        fileHashes.push(addedHash);
                        addHashesCounter -= 1;

                        if (addHashesCounter === 0) {

                            if (addHashesError) {
                                self.result.setSuccess(false);
                                callback(addHashesError, self.result);
                                return;
                            }

                            var artifactSaveCallback = function (err, artifactHash) {
                                if (err) {
                                    self.result.setSuccess(false);
                                    callback(err, self.result);
                                    return;
                                }

                                self.logger.info('Saved artifact hashes are: ' + artifactHash);

                                self.result.addArtifact(artifactHash);

                                self.result.setSuccess(true);

                                // This will save the changes. If you don't want to save;
                                // exclude self.save and call callback directly from this scope.
                                self.save('Finished FmiExporter', function (err) {
                                    if (err) {
                                        self.result.setSuccess(false);
                                        callback(err, self.result);
                                        return;
                                    }

                                    callback(null, self.result);
                                });
                            };

                            artifact.save(artifactSaveCallback);
                        }
                    };

                    for (i = 0; i < fmuPackageHashMapKeys.length; i += 1) {
                        // PM: Semi colon.
                        fmuPathWithinArtifact = fmuPackageHashMapKeys[i],
                        fmuHash = self.fmuPackageHashMap[fmuPathWithinArtifact];
                        artifact.addObjectHash(fmuPathWithinArtifact, fmuHash, addHashCounterCallback);
                    }
                };

                artifact.addFiles(self.filesToSave, addFilesCallback);
            };

            self.extractModelExchangeConfigInfo(childNodes, extractMeConfigInfoCallback);
        };

        self.core.loadChildren(modelExchangeNode, loadModelExchangeChildrenCallbackFunction);
    };

    // An asynchronous function to iterate over the ModelExchange children and extract info
    FmiExporter.prototype.extractModelExchangeConfigInfo = function (modelExchangeChildren, callback) {
        var self = this,
            i,
            meChildNode,
            meChildName,
            metaTypeNode,
            metaTypePath,
            counter = modelExchangeChildren.length,
            error = '',
            srcPath,
            dstPath,
            splitPath,
            srcIds,
            dstIds;

        var iterationCallback = function (err) {
            if (err) {
                error += err;
            }

            counter -= 1;
            // PM: check for counter <= 0 and call it if modeExhangeChildren.length === 0
            if (counter === 0) {
                callback(error);
            }
        };

        var loadFmuChildrenCallbackFunction = function (fmuName) {
            return function (loadChildrenErr, fmuChildren) {
                if (fmuChildren.length === 0) {
                    var newErrorMessage = fmuName + " had no child objects";
                    loadChildrenErr += newErrorMessage;  //"FMU had no child objects";
                    iterationCallback(loadChildrenErr);
                    // PM: return;
                }

                var fmuInstanceNode = self.core.getParent(fmuChildren[0]),
                    fmuInstanceName = self.core.getAttribute(fmuInstanceNode, 'name'),
                    fmuInstanceAssetHash = self.core.getAttribute(fmuInstanceNode, 'resource'),
                    fmuBaseNode = self.core.getBase(fmuInstanceNode),
                    fmuBaseName = self.core.getAttribute(fmuBaseNode, 'name'),
                    fmuBaseAssetHash = self.core.getAttribute(fmuBaseNode, 'resource'),
                    //relid = self.core.getRelid(fmuInstanceNode),
                    fullPath = self.core.getPath(fmuInstanceNode),
                    fmuInfo;
                // PM: Move this up.
                fmuInfo = self.extractFmuInfo(fmuChildren);

                fmuInfo['InstanceName'] = fmuInstanceName;
                fmuInfo['Priority'] = 1;  // Initialize to 1, 'assignPriority' will overwrite

                if (fmuInstanceAssetHash === fmuBaseAssetHash) {
                    // PM: Use /, \ only works on windows.
                    fmuInfo['File'] = 'FMUs\\' + fmuBaseName + '.fmu';
                    fmuInfo['Asset'] = self.core.getAttribute(fmuBaseNode, 'resource');
                } else {
                    fmuInfo['File'] = 'FMUs\\' + fmuInstanceName + '.fmu';
                    fmuInfo['Asset'] = self.core.getAttribute(fmuInstanceNode, 'resource');
                }

                self.fmuPackageHashMap[fmuInfo.File] = fmuInfo.Asset;

                //self.fmuIdToInfoMap[relid] = fmuInfo;
                self.fmuIdToInfoMap[fullPath] = fmuInfo;

                iterationCallback(loadChildrenErr);
            };
        };

        for (i = 0; i < modelExchangeChildren.length; i += 1) {

            meChildNode = modelExchangeChildren[i];
            meChildName = self.core.getAttribute(meChildNode, 'name');
            metaTypeNode = self.getMetaType(meChildNode);
            metaTypePath = self.core.getPath(metaTypeNode);

            // FIXME: this condition is fine now, but will not work correctly if we have a more complicated inheritance
            //        in the meta model.
            // PM: isMetaTypeOf takes care of the inheritance.
            if (metaTypeNode === FmuMetaTypes.PortComposition) {

                srcPath = self.core.getPointerPath(meChildNode, 'src');
                dstPath = self.core.getPointerPath(meChildNode, 'dst');

                if (srcPath) {
                    srcIds = srcPath;

//                    splitPath = srcPath.split('/');
//                    if (splitPath.length > 2) {
//                        srcIds = splitPath.slice(-2).join('/');
//                    }
                } else {
                    // PM: You need to continue after this call - if that's the intention.
                    iterationCallback("PortComposition has no SrcPointer.");
                }
                if (dstPath) {
                    dstIds = dstPath;

//                    splitPath = dstPath.split('/');
//                    if (splitPath.length > 2) {
//                        dstIds = splitPath.slice(-2).join('/');
//                    }
                } else {
                    // PM: You need to continue after this call - if that's the intention.
                    iterationCallback("PortComposition has no DstPointer");
                }

                if (self.connectionMap.hasOwnProperty(srcIds)) {
                    self.connectionMap[srcIds].push(dstIds);

                } else {
                    self.connectionMap[srcIds] = [dstIds];
                }

                iterationCallback(null);

            } else if (metaTypeNode === FmuMetaTypes.FMU) {
                // asynchronous call to get parameter and port information
                self.core.loadChildren(meChildNode, loadFmuChildrenCallbackFunction(meChildName));

            } else if (metaTypeNode === FmuMetaTypes.SimulationParameter) {
                if (self.simulationInfo.hasOwnProperty(meChildName)) {
                    self.simulationInfo[meChildName] = self.core.getAttribute(meChildNode, 'value');
                }

                iterationCallback(null);
            }

        }
    };

    FmiExporter.prototype.assignPriorityAndFlatten = function () {
        // PM: There's probably too many variables declared in this method.
        // Will be more transparent when you move all declarations to the top.
        var self = this,
            fmuMapKeys = Object.keys(self.fmuIdToInfoMap),
            connMapKeys = Object.keys(self.connectionMap),
            connMapKey,
            fmuId,
            fmu,
            fmuHash,
            fmuPriority,
            fmuPath,
            i;

        //for (i = 0; i < fmuMapKeys.length; i += 1) {
        for (fmuPath in self.fmuIdToInfoMap) {
            // PM: Comma should only be used in declarations, i.e. var a, b, c;
            //fmuId = fmuMapKeys[i],
            //fmu = self.fmuIdToInfoMap[fmuId],
            fmu = self.fmuIdToInfoMap[fmuPath],
            fmuHash = fmu.Asset,
            fmuPriority = fmu.Priority;

            if (fmuPriority === 1) {
                self.followConnsAssignPriority(fmuId, fmu);
            }

            //self.fmuPackageHashMap[fmu.Name] = fmuHash;
            self.fmus.push(fmu);
        }

        var splitKey,
            srcFmu,
            srcPriority,
            srcFmuId,
            srcFmuName,
            srcPortId,
            srcPortPath,
            srcPortName,
            dstConnections,
            dstConnIds,
            splitIds,
            dstFmu,
            dstPriority,
            dstFmuId,
            dstFmuName,
            dstPortId,
            dstPortName,
            flatConnInfo,
            j;

        //for (i = 0; i < connMapKeys.length; i += 1) {
        for (srcPortPath in self.connectionMap) {
            //connMapKey = connMapKeys[i];
            splitKey = connMapKey.split('/');
            srcFmuId = splitKey[0];
            srcPortId = splitKey[1];
            srcFmu = self.fmuIdToInfoMap[srcFmuId];
            srcFmuName = srcFmu.InstanceName;
            srcPriority = srcFmu.Priority;
            srcPortName = srcFmu.OutputMap[srcPortId];
            dstConnections = self.connectionMap[connMapKey];

            for (j = 0; j < dstConnections.length; j += 1) {
                dstConnIds = dstConnections[j];
                splitIds = dstConnIds.split('/');
                dstFmuId = splitIds[0];
                dstPortId = splitIds[1];
                dstFmu = self.fmuIdToInfoMap[dstFmuId];
                dstFmuName = dstFmu.InstanceName;
                dstPriority = dstFmu.Priority;
                dstPortName = dstFmu.InputMap[dstPortId];

                flatConnInfo = {
                    'Source': srcFmuName + '.' + srcPortName,
                    'Destination': dstFmuName + '.' + dstPortName,
                    'SrcPriority': srcPriority,
                    'DstPriority': dstPriority
                };

                self.connections.push(flatConnInfo);
            }
        }
    };

    FmiExporter.prototype.followConnsAssignPriority = function (srcFmuId, srcFmu) {
        var self = this,
            srcFmuName = srcFmu.InstanceName,
            srcFmuOutputs = srcFmu.OutputMap,
            outputIds = Object.keys(srcFmuOutputs),
            srcPriority = srcFmu.Priority,
            dstPriority = srcPriority + 1,
            numberOutputs = outputIds.length,
            i,
            j;

        if (numberOutputs === 0) {
            self.logger.debug(srcFmu.InstanceName + " has no Outputs.");
            return;
        }

        for (i = 0; i < outputIds.length; i += 1) {
            var outputId = outputIds[i],
                outputName = srcFmuOutputs[outputId],
                connMapKey = srcFmuId + '/' + outputId;

            if (self.connectionMap.hasOwnProperty(connMapKey) === false) {
                self.logger.debug("No connections leaving from " + srcFmuName + "." + outputName);
                continue;
            }

            // Could be multiple connections leaving this port
            var allConnections = self.connectionMap[connMapKey];

            for (j = 0; j < allConnections.length; j += 1) {
                var connectedInput = allConnections[j],
                    dstFmuId = connectedInput.split("/")[0],
                    dstPortId = connectedInput.split("/")[1],
                    dstFmu = self.fmuIdToInfoMap[dstFmuId],
                    dstPortName = dstFmu.InputMap[dstPortId];

                if (dstFmu.Priority < dstPriority) {
                    dstFmu.Priority = dstPriority;
                }

                // dst becomes src, repeat
                self.followConnsAssignPriority(dstFmuId, dstFmu);
            }
        }
    };

    // a Synchronous helper function to get FMU Parameters, Inputs, and Outputs
    FmiExporter.prototype.extractFmuInfo = function (fmuChildren) {
        var self = this,
            i,
            fmuChildNode,
            fmuChildNodeRelid,
            fmuChildNodeName,
            baseTypeNode,
            baseTypePath,
            parameters = {},
            inputMap = {},
            outputMap = {},
            inputs = [],
            outputs = [],
            fmuInfo = {};

        for (i = 0; i < fmuChildren.length; i += 1) {

            fmuChildNode = fmuChildren[i];
            fmuChildNodeRelid = self.core.getRelid(fmuChildNode); // FIXME: getPath?
            fmuChildNodeName = self.core.getAttribute(fmuChildNode, 'name');
            baseTypeNode = self.getMetaType(fmuChildNode);
            baseTypePath = self.core.getPath(baseTypeNode);

            if (baseTypeNode === FmuMetaTypes.Parameter) {
                parameters[fmuChildNodeName] = self.core.getAttribute(fmuChildNode, 'value');

            } else if (baseTypeNode === FmuMetaTypes.Input) {
                inputMap[fmuChildNodeRelid] = fmuChildNodeName;
                inputs.push(fmuChildNodeName);

            } else if (baseTypeNode === FmuMetaTypes.Output) {
                outputMap[fmuChildNodeRelid] = fmuChildNodeName;
                outputs.push(fmuChildNodeName);
            }
        }
        // PM: Use the below. (Otherwise you're modifying the object multiple times.)
        // (There is no need to initialize it then.)
        // fmuInfo = {
        //    Parameters: parameters,
        //    Inputs: inputs,
        //      ...
        //  };
        // You can also return the object directly.
        fmuInfo['Parameters'] = parameters;
        fmuInfo['Inputs'] = inputs;
        fmuInfo['InputMap'] = inputMap;
        fmuInfo['Outputs'] = outputs;
        fmuInfo['OutputMap'] = outputMap;

        return fmuInfo;
    };

    /**
    * Checks if the given node is of the given meta-type.
    * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>
    * @param node - Node to be check for type.
    * @param metaTypeObj - Node object defining the meta type.
    * @returns {boolean} - True if the given object was of the META type.
    */
    FmiExporter.prototype.isMetaTypeOf = function (node, metaTypeObj) {
        var self = this;
        while (node) {
            if (self.core.getGuid(node) === self.core.getGuid(metaTypeObj)) {
                return true;
            }
            node = self.core.getBase(node);
        }
        return false;
    };

    /**
    * Finds and returns the node object defining the meta type for the given node.
    * @param node - Node to be check for type.
    * @returns {Object} - Node object defining the meta type of node.
    */
    FmiExporter.prototype.getMetaType = function (node) {
        var self = this,
            name;
        while (node) {
            name = self.core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                break;
            }
            node = self.core.getBase(node);
        }
        return node;
    };

    return FmiExporter;
});

