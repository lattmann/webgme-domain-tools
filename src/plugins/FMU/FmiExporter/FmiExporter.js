/**
* Generated by PluginGenerator from webgme on Wed Apr 16 2014 16:05:02 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'ejs',
        'plugin/FmiExporter/FmiExporter/Templates/Templates'],
    function (PluginConfig, PluginBase, EJS, TEMPLATES) {
    'use strict';

    /**
    * Initializes a new instance of FmiExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin FmiExporter.
    * @constructor
    */
    var FmiExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.fmusInModelExchange = 0;
        this.fmuIdToInfoMap = {};
        this.fmuGuidToInfoMap = {};
        this.connections = [];
        this.simulationInfo = {};
        this.modelExchangeConfig = {};
        this.fmiMetaTypes = {
            'FMU': '/1822302751/902541625',
            'PortComposition': '/1822302751/472382791',
            'Input': '/1822302751/873609603',
            'Output': '/1822302751/206401000',
            'Parameter': '/1822302751/1582216564',
            'SimulationParameter': '/1822302751/1963127367'
        };
    };

    // Prototypal inheritance from PluginBase.
    FmiExporter.prototype = Object.create(PluginBase.prototype);
    FmiExporter.prototype.constructor = FmiExporter;

    if (!ejs) {
        ejs = EJS || window.ejs;
    }

    /**
    * Gets the name of the FmiExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    FmiExporter.prototype.getName = function () {
        return "FMI ModelExchange Exporter";
    };

    /**
    * Gets the description of the FmiExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    FmiExporter.prototype.getDescription = function () {
        return "Generates a model_exchange_config.json for simulating a FMI system";
    };

    /**
    * Gets the semantic version (semver.org) of the FmiExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    FmiExporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always have to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    FmiExporter.prototype.main = function (callback) {
        var self = this,
            selectedNode = self.activeNode;

        if (!selectedNode) {
            callback('selectedNode is not defined', pluginResult);
            return;
        }

        // core.loadChildren returns err and childNodes
        var loadModelExchangeChildrenCallbackFunction = function (err, childNodes) {
            if (err) {
                self.logger.error('Something went wrong getting child nodes');
                callback('Something went wrong getting child nodes', self.result);
                return;
            }

            var generateMeCfgCallbackFunction = function (err) {

                if (err) {
                    self.result.setSuccess(false);
                    callback(err, self.result);
                    return;
                }

                self.result.setSuccess(true);

                // This will save the changes. If you don't want to save;
                // exclude self.save and call callback directly from this scope.
                self.save('Finished FmiExporter', function (err) {
                    callback(null, self.result);
                });
            };

            self.generateModelExchangeConfig(childNodes, generateMeCfgCallbackFunction);
        };

        self.core.loadChildren(selectedNode, loadModelExchangeChildrenCallbackFunction);
    };

    // An asynchronous function to iterate over the ModelExchange children and extract info
    FmiExporter.prototype.generateModelExchangeConfig = function (modelExchangeChildren, callback) {
        var self = this,
            i,
            meChildNode,
            baseTypeNode,
            baseTypePath,
            counter = modelExchangeChildren.length,
            error = '';

        var iterationCallback = function (err) {
            if (err) {
                error += err;
            }

            counter -= 1;

            if (counter === 0) {
                callback(error);
            }
        };

        var loadFmuChildrenCallbackFunction = function (loadChildrenErr, fmuChildren) {
            self.addFmu(fmuChildren);
            iterationCallback(loadChildrenErr);
        };

        for (i = 0; i < modelExchangeChildren.length; i += 1) {

            meChildNode = modelExchangeChildren[i];
            baseTypeNode = self.getMetaType(meChildNode);
            baseTypePath = self.core.getPath(baseTypeNode);

            if (baseTypePath === self.fmiMetaTypes.PortComposition) {

                var srcPath = self.core.getPointerPath(meChildNode, 'src'),
                    srcFmuIds = srcPath.split('/').slice(-2),
                    dstPath = self.core.getPointerPath(meChildNode, 'dst'),
                    dstFmuIds = dstPath.split('/').slice(-2),
                    srcPriority = 0,
                    dstPriority = srcPriority + 1;

                var connInfo = {
                    'Source': srcFmuIds,
                    'Destination': dstFmuIds,
                    'SrcPriority': srcPriority,
                    'DstPriority': dstPriority
                };

                self.connections.push(connInfo);

                self.logger.info("Src and Dst are found!");

                iterationCallback(null);

            } else if (baseTypePath === self.fmiMetaTypes.FMU) {

                var relid = self.core.getRelid(meChildNode);

                var fmuInfo = {
                    'Name': self.core.getAttribute(meChildNode, 'name'),
                    'File': self.core.getAttribute(meChildNode, 'fmu_path'),
                    'Priority': 1,
                    'node': meChildNode
                };

                self.fmuIdToInfoMap[relid] = fmuInfo;

                // asynchronous call to get parameter and port information
                self.core.loadChildren(meChildNode, loadFmuChildrenCallbackFunction);

            } else if (baseTypePath === self.fmiMetaTypes.SimulationParameter) {

                iterationCallback(null);
            }



            self.logger.info("We have reached the debug point!");

        }
    };

        // a Synchronous helper function to get FMU Parameters, Inputs, and Outputs
        FmiExporter.prototype.addFmu = function (fmuChildren, fmuInfo) {
            var self = this,
                i,
                fmuChildNode,
                baseTypeNode,
                baseTypePath,
                parameters = {},
                inputs = [],
                outputs = [];

            for (i = 0; i < fmuChildren.length; i += 1) {

                fmuChildNode = fmuChildren[i];
                baseTypeNode = self.getMetaType(fmuChildNode);
                baseTypePath = self.core.getPath(baseTypeNode);

                if (baseTypePath === self.fmiMetaTypes.Parameter) {
                    parameters[self.core.getAttribute(fmuChildNode, 'name')] = self.core.getAttribute(fmuChildNode, 'value');
                }
                else if (baseTypePath === self.fmiMetaTypes.Input) {
                    inputs.push(self.core.getAttribute(fmuChildNode, 'name'));
                }
                else if (baseTypePath === self.fmiMetaTypes.Output) {
                    outputs.push(self.core.getAttribute(fmuChildNode, 'name'));
                }
            }

            fmuInfo['Parameters'] = parameters;
            fmuInfo['Inputs'] = inputs;
            fmuInfo['Outputs'] = outputs;

            return fmuInfo;
        };

    /**
    * Checks if the given node is of the given meta-type.
    * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>
    * @param node - Node to be check for type.
    * @param metaTypeObj - Node object defining the meta type.
    * @returns {boolean} - True if the given object was of the META type.
    */
    FmiExporter.prototype.isMetaTypeOf = function (node, metaTypeObj) {
        var self = this;
        while (node) {
            if (self.core.getGuid(node) === self.core.getGuid(metaTypeObj)) {
                return true;
            }
            node = self.core.getBase(node);
        }
        return false;
    };

    /**
    * Finds and returns the node object defining the meta type for the given node.
    * @param node - Node to be check for type.
    * @returns {Object} - Node object defining the meta type of node.
    */
    FmiExporter.prototype.getMetaType = function (node) {
        var self = this,
            name;
        while (node) {
            name = self.core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                break;
            }
            node = self.core.getBase(node);
        }
        return node;
    };

    return FmiExporter;
});

