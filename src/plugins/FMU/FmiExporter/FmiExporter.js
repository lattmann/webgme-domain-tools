/**
* Generated by PluginGenerator from webgme on Wed Apr 16 2014 16:05:02 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
        'plugin/PluginBase',
        'plugin/FmiExporter/FmiExporter/FMU',
        'plugin/FmiExporter/FmiExporter/Templates/Templates',
        'ejs'], function (PluginConfig, PluginBase, FmuMetaTypes, ejs, TEMPLATES) {
    // PM: This change saves you one indent (or JSLint complaints for each method).
    'use strict';

    /**
    * Initializes a new instance of FmiExporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin FmiExporter.
    * @constructor
    */
    var FmiExporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.pathToFmuInfo = {};
        this.path2port = {};
        this.path2node = {};

        this.fmuIdToInfoMap = {};
        this.fmus = [];
        this.fmuPackageHashMap = {};
        this.connectionMap = {};
        this.connections = [];
        this.simulationInfo = {
            'StartTime': 0,
            'StopTime': 1,
            'StepSize': 0.001
        };
        this.modelExchangeConfig = {};
        this.filesToSave = {};
    };

    // Prototype inheritance from PluginBase.
    FmiExporter.prototype = Object.create(PluginBase.prototype);
    FmiExporter.prototype.constructor = FmiExporter;

    /**
    * Gets the name of the FmiExporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    FmiExporter.prototype.getName = function () {
        return 'FMI ModelExchange Exporter';
    };

    /**
    * Gets the description of the FmiExporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    FmiExporter.prototype.getDescription = function () {
        return 'Generates a model_exchange_config.json for simulating a FMI system';
    };

    /**
    * Gets the semantic version (semver.org) of the FmiExporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    FmiExporter.prototype.getVersion = function () {
        return '0.1.0';
    };

//    /**
//    * Main function for the plugin to execute. This will perform the execution.
//    * Notes:
//    * - Always log with the provided logger.[error,warning,info,debug].
//    * - Do NOT put any user interaction logic UI, etc. inside this method.
//    * - callback always have to be called even if error happened.
//    *
//    * @param {function(string, plugin.PluginResult)} callback - the result callback
//    */
//    FmiExporter.prototype.main = function (callback) {
//        var self = this,
//            selectedNode = self.activeNode,
//            modelExchangeName = self.core.getAttribute(selectedNode, 'name'),
//            modelExchangeNode;
//
//        if (!selectedNode) {
//            callback('selectedNode is not defined', self.result);
//            return;
//        }
//
//        this.updateMETA(FmuMetaTypes);
//
//        if (self.isMetaTypeOf(selectedNode, FmuMetaTypes.ModelExchange)) {
//            modelExchangeNode = selectedNode;
//        } else {
//            callback('SelectedNode is not a ModelExchange!', self.result);
//            return;
//        }
//
//        var loadModelExchangeChildrenCallbackFunction = function (err, childNodes) {
//            if (err) {
//                var msg = "Something went wrong getting child nodes";
//                self.logger.error(msg);
//                callback(msg, self.result);
//                return;
//            }
//
//            var extractMeConfigInfoCallback = function (err) {
//                if (err) {
//                    self.result.setSuccess(false);
//                    callback(err, self.result);
//                    return;
//                }
//
//                self.assignPriorityAndFlatten();
//                //self.runTarjans();
//
//                var artifact = self.blobClient.createArtifact(modelExchangeName);
//
//                self.modelExchangeConfig['Connections'] = self.connections;
//                self.modelExchangeConfig['FMUs'] = self.fmus;
//                self.modelExchangeConfig['SimulationInfo'] = self.simulationInfo;
//                var fileInfo = JSON.stringify(self.modelExchangeConfig, null, 4);
//
//                var tt1 = ejs.render(TEMPLATES['fmi_wrapper.py.ejs']);
//                var tt2 = ejs.render(TEMPLATES['jmodelica_model_exchange.py.ejs']);
//                var tt3 = ejs.render(TEMPLATES['run_jmodelica_model_exchange.cmd.ejs']);
//                var tt4 = ejs.render(TEMPLATES['ReadMe.txt.ejs']);
//
//                self.filesToSave['model_exchange_config.json'] = fileInfo;
//                self.filesToSave['fmi_wrapper.py'] = tt1;
//                self.filesToSave['jmodelica_model_exchange.py'] = tt2;
//                self.filesToSave['run_jmodelica_model_exchange.cmd'] = tt3;
//                self.filesToSave['ReadMe.txt'] = tt4;
//
//                var addFilesCallback = function (err, fileHashes) {
//                    if (err) {
//                        self.result.setSuccess(false);
//                        callback(err, self.result);
//                        return;
//                    }
//
//                    var i,
//                        fmuPackageName,
//                        fmuPathWithinArtifact,
//                        fmuHash,
//                        fmuPackageHashMapKeys = Object.keys(self.fmuPackageHashMap),
//                        addHashesError,
//                        addHashesCounter = fmuPackageHashMapKeys.length;
//
//                    var addHashCounterCallback = function (addHashCallbackError, addedHash) {
//                        if (addHashCallbackError) {
//                            addHashesError += addHashCallbackError;
//                        }
//
//                        fileHashes.push(addedHash);
//                        addHashesCounter -= 1;
//
//                        if (addHashesCounter === 0) {
//
//                            if (addHashesError) {
//                                self.result.setSuccess(false);
//                                callback(addHashesError, self.result);
//                                return;
//                            }
//
//                            var artifactSaveCallback = function (err, artifactHash) {
//                                if (err) {
//                                    self.result.setSuccess(false);
//                                    callback(err, self.result);
//                                    return;
//                                }
//
//                                self.logger.info('Saved artifact hashes are: ' + artifactHash);
//
//                                self.result.addArtifact(artifactHash);
//
//                                self.result.setSuccess(true);
//
//                                // This will save the changes. If you don't want to save;
//                                // exclude self.save and call callback directly from this scope.
//                                self.save('Finished FmiExporter', function (err) {
//                                    if (err) {
//                                        self.result.setSuccess(false);
//                                        callback(err, self.result);
//                                        return;
//                                    }
//
//                                    callback(null, self.result);
//                                });
//                            };
//
//                            artifact.save(artifactSaveCallback);
//                        }
//                    };
//
//                    for (i = 0; i < fmuPackageHashMapKeys.length; i += 1) {
//                        // PM: Semi colon.
//                        fmuPathWithinArtifact = fmuPackageHashMapKeys[i],
//                        fmuHash = self.fmuPackageHashMap[fmuPathWithinArtifact];
//                        artifact.addObjectHash(fmuPathWithinArtifact, fmuHash, addHashCounterCallback);
//                    }
//                };
//
//                artifact.addFiles(self.filesToSave, addFilesCallback);
//            };
//
//            self.extractModelExchangeConfigInfo(childNodes, extractMeConfigInfoCallback);
//        };
//
//        self.core.loadChildren(modelExchangeNode, loadModelExchangeChildrenCallbackFunction);
//    };
//


    FmiExporter.prototype.main = function (callback) {
        var self = this,
            selectedNode = self.activeNode,
            modelExchangeNode;

        if (!selectedNode) {
            callback('selectedNode is not defined', self.result);
            return;
        }

        this.updateMETA(FmuMetaTypes);

        if (self.isMetaTypeOf(selectedNode, FmuMetaTypes.ModelExchange)) {
            modelExchangeNode = selectedNode;
        } else {
            callback('SelectedNode is not a ModelExchange!', self.result);
            return;
        }

        var nodesAreLoadedCallbackFunction = function (err) {
            if (err) {
                var msg = 'Something went wrong getting loading child nodes';
                self.logger.error(msg);
                return callback(msg, self.result);
            }

            self.logger.info('All nodes have been loaded.');

            self.buildModelExchangeConfig();

            self.logger.info('meConfig');
        };

        var nodeCount = 0;
        self.loadAllNodesRecursive(modelExchangeNode, nodeCount, null, nodesAreLoadedCallbackFunction);
    }

    FmiExporter.prototype.buildModelExchangeConfig = function () {
        var self = this,
            thisNode,
            thisNodeName,
            thisNodePath,
            parentFmuPath,
            parentFmuInfo,
            connSrcPath,
            connDstPath;

        for (thisNodePath in self.path2node) {
            thisNode = self.path2node[thisNodePath];
            thisNodeName = self.core.getAttribute(thisNode, 'name');

            if (self.isMetaTypeOf(thisNode, FmuMetaTypes.PortComposition)) {

                connSrcPath = self.core.getPointerPath(thisNode, 'src');
                connDstPath = self.core.getPointerPath(thisNode, 'dst');

                if (connSrcPath && connDstPath) {
                    if (self.connectionMap.hasOwnProperty(connSrcPath)) {
                        self.connectionMap[connSrcPath].push(connDstPath);   // append to existing list of destinations

                    } else {
                        self.connectionMap[connSrcPath] = [connDstPath];
                    }
                } else {
                    var portCompositionPath = self.core.getPath(thisNode);
                    iterationCallback('PortComposition (' + portCompositionPath + ') is missing a SrcPointer or DstPointer.');
                    continue;
                }

            } else if (self.isMetaTypeOf(thisNode, FmuMetaTypes.FMU)) {
                if (!self.pathToFmuInfo.hasOwnProperty(parentFmuPath)) {
                    self.getFmuInfo(thisNodePath, thisNode, thisNodeName);
                }

            } else if (self.isMetaTypeOf(thisNode, FmuMetaTypes.Parameter)) {
                parentFmuPath = self.getParentPath(thisNodePath);

                if (!self.pathToFmuInfo.hasOwnProperty(parentFmuPath)) {
                    parentFmuInfo = self.getFmuInfo(parentFmuPath);
                } else {
                    parentFmuInfo = self.pathToFmuInfo[parentFmuPath];
                }

                parentFmuInfo.Parameters[thisNodeName] = self.core.getAttribute(thisNode, 'value');
            } else if (self.isMetaTypeOf(thisNode, FmuMetaTypes.Input)) {
                parentFmuPath = self.getParentPath(thisNodePath);

                if (!self.pathToFmuInfo.hasOwnProperty(parentFmuPath)) {
                    parentFmuInfo = self.getFmuInfo(parentFmuPath);
                } else {
                    parentFmuInfo = self.pathToFmuInfo[parentFmuPath];
                }

                parentFmuInfo = self.pathToFmuInfo[parentFmuPath];
                parentFmuInfo.Inputs[thisNodePath] = thisNodeName;
            } else if (self.isMetaTypeOf(thisNode, FmuMetaTypes.Output)) {
                parentFmuPath = self.getParentPath(thisNodePath);

                if (!self.pathToFmuInfo.hasOwnProperty(parentFmuPath)) {
                    parentFmuInfo = self.getFmuInfo(parentFmuPath);
                } else {
                    parentFmuInfo = self.pathToFmuInfo[parentFmuPath];
                }

                parentFmuInfo.Outputs[thisNodePath] = thisNodeName;
            } else if (self.isMetaTypeOf(thisNode, FmuMetaTypes.SimulationParameter)) {
                if (self.simulationInfo.hasOwnProperty(meChildName)) {
                    self.simulationInfo[meChildName] = self.core.getAttribute(meChildNode, 'value');
                }
            }
        }
    };

    FmiExporter.prototype.getFmuInfo = function (fmuNodePath, fmuNode, fmuNodeName) {
        var self = this;
        fmuNode = fmuNode || self.path2node(fmuNodePath);
        fmuNodeName = fmuNodeName || self.core.getAttribute(fmuNode, 'name');

        var fmuInstanceAssetHash = self.core.getAttribute(fmuNode, 'resource'),
            fmuBaseNode = self.core.getBase(fmuNode),
            fmuBaseName = self.core.getAttribute(fmuBaseNode, 'name'),
            fmuBaseAssetHash = self.core.getAttribute(fmuBaseNode, 'resource'),
            fmuInfo = {
                'InstanceName': fmuNodeName,
                'Priority': 1,
                'Parameters': {},
                'Inputs': {},
                'Outputs': {}
            };

        if (fmuInstanceAssetHash === fmuBaseAssetHash) {
            fmuInfo['File'] = 'FMUs/' + fmuBaseName + '.fmu';
            fmuInfo['Asset'] = self.core.getAttribute(fmuBaseNode, 'resource');
        } else {
            fmuInfo['File'] = 'FMUs/' + fmuNodeName + '.fmu';
            fmuInfo['Asset'] = self.core.getAttribute(fmuNode, 'resource');
        }

        self.fmuPackageHashMap[fmuInfo.File] = fmuInfo.Asset;
        self.pathToFmuInfo[fmuNodePath] = fmuInfo;

        return fmuInfo;
    };

    FmiExporter.prototype.getParentPath = function (childPath) {
        var splitPath = childPath.split('/'),
            slicedPath = splitPath.slice(0, -1),
            parentPath = slicedPath.join('/');

        return parentPath;
    };

    FmiExporter.prototype.loadAllNodesRecursive = function (parentNode, nodeCount, errors, callback) {
        var self = this;

        var loadChildrenCallbackFunction = function (err, children) {
            if (err) {
                errors += err;
            }

            var childNodes = children;

            nodeCount += childNodes.length;

            if (nodeCount === 0) {
                callback(errors);
            }

            for (var i = 0; i < childNodes.length; i += 1) {
                self.path2node[self.core.getPath(childNodes[i])] = childNodes[i];
                nodeCount -= 1;
                self.loadAllNodesRecursive(childNodes[i], nodeCount, errors, callback)
            }
        };

        self.core.loadChildren(parentNode, loadChildrenCallbackFunction);
    };

    // An asynchronous function to iterate over the ModelExchange children and extract info
    FmiExporter.prototype.extractModelExchangeConfigInfo = function (modelExchangeChildren, callback) {
        var self = this,
            i,
            meChildNode,
            meChildName,
            counter = modelExchangeChildren.length,
            error = '',
            srcPath,
            dstPath;

        var iterationCallback = function (err) {
            if (err) {
                error += err;
            }

            counter -= 1;

            if (counter === 0) {
                callback(error);
            }
        };

        var loadFmuChildrenCallbackFunction = function (fmuName, fmuNode) {
            return function (loadChildrenErr, fmuChildren) {
                if (fmuChildren.length === 0) {
                    var newErrorMessage = fmuName + ' had no child objects';
                    loadChildrenErr += newErrorMessage;  //"FMU had no child objects";
                    iterationCallback(loadChildrenErr);
                    return;
                }

                var fmuInfo = self.extractFmuInfo(fmuChildren),
                    fmuInstanceName = self.core.getAttribute(fmuNode, 'name'),
                    fmuInstancePath = self.core.getPath(fmuNode),
                    fmuInstanceAssetHash = self.core.getAttribute(fmuNode, 'resource'),
                    fmuBaseNode = self.core.getBase(fmuNode),
                    fmuBaseName = self.core.getAttribute(fmuBaseNode, 'name'),
                    fmuBaseAssetHash = self.core.getAttribute(fmuBaseNode, 'resource');

                fmuInfo['InstanceName'] = fmuInstanceName;
                fmuInfo['Priority'] = 1;  // Initialize to 1, 'assignPriority' will overwrite

                if (fmuInstanceAssetHash === fmuBaseAssetHash) {
                    fmuInfo['File'] = 'FMUs/' + fmuBaseName + '.fmu';
                    fmuInfo['Asset'] = self.core.getAttribute(fmuBaseNode, 'resource');
                } else {
                    fmuInfo['File'] = 'FMUs/' + fmuInstanceName + '.fmu';
                    fmuInfo['Asset'] = self.core.getAttribute(fmuNode, 'resource');
                }

                self.fmuPackageHashMap[fmuInfo.File] = fmuInfo.Asset;

                self.fmuIdToInfoMap[fmuInstancePath] = fmuInfo;
                self.pathToFmuInfo[fmuInstancePath] = fmuInfo;

                iterationCallback(loadChildrenErr);
            };
        };

        for (i = 0; i < modelExchangeChildren.length; i += 1) {

            meChildNode = modelExchangeChildren[i];
            meChildName = self.core.getAttribute(meChildNode, 'name');

            if (self.isMetaTypeOf(meChildNode, FmuMetaTypes.PortComposition)) {

                srcPath = self.core.getPointerPath(meChildNode, 'src');
                dstPath = self.core.getPointerPath(meChildNode, 'dst');

                if (srcPath && dstPath) {
                    if (self.connectionMap.hasOwnProperty(srcPath)) {
                        self.connectionMap[srcPath].push(dstPath);   // append to existing list of destinations

                    } else {
                        self.connectionMap[srcPath] = [dstPath];
                    }
                } else {
                    var portCompositionPath = self.core.getPath(meChildNode);
                    iterationCallback('PortComposition (' + portCompositionPath + ') is missing a SrcPointer or DstPointer.');
                    continue;
                }

                iterationCallback(null);

            } else if (self.isMetaTypeOf(meChildNode, FmuMetaTypes.FMU)) {
                // asynchronous call to get parameter and port information
                self.core.loadChildren(meChildNode, loadFmuChildrenCallbackFunction(meChildName, meChildNode));

            } else if (self.isMetaTypeOf(meChildNode, FmuMetaTypes.SimulationParameter)) {
                if (self.simulationInfo.hasOwnProperty(meChildName)) {
                    self.simulationInfo[meChildName] = self.core.getAttribute(meChildNode, 'value');
                }

                iterationCallback(null);
            }
        }
    };

    FmiExporter.prototype.assignPriorityAndFlatten = function () {
        var self = this,
            connMapKey,
            fmu,
            fmuHash,
            fmuPriority,
            fmuPath,
            i;

        for (fmuPath in self.pathToFmuInfo) {
            fmu = self.pathToFmuInfo[fmuPath];
            fmuHash = fmu.Asset;
            fmuPriority = fmu.Priority;

            if (fmuPriority === 1) {
                self.followConnsAssignPriority(fmuPath, fmu);
            }

            self.fmus.push(fmu);
        }

        var splitKey,
            srcFmu,
            srcPriority,
            srcFmuId,
            srcFmuName,
            srcPortId,
            srcPortPath,
            srcPortName,
            dstConnections,
            dstConnIds,
            splitIds,
            dstFmu,
            dstPriority,
            dstFmuId,
            dstFmuName,
            dstPortId,
            dstPortName,
            flatConnInfo,
            j;

        for (srcPortPath in self.connectionMap) {
            splitKey = connMapKey.split('/');
            srcFmuId = splitKey[-2];
            srcPortId = splitKey[-1];
            srcFmu = self.fmuIdToInfoMap[srcFmuId];
            srcFmuName = srcFmu.InstanceName;
            srcPriority = srcFmu.Priority;
            srcPortName = srcFmu.OutputMap[srcPortId];
            dstConnections = self.connectionMap[connMapKey];

            for (j = 0; j < dstConnections.length; j += 1) {
                dstConnIds = dstConnections[j];
                splitIds = dstConnIds.split('/');
                dstFmuId = splitIds[0];
                dstPortId = splitIds[1];
                dstFmu = self.fmuIdToInfoMap[dstFmuId];
                dstFmuName = dstFmu.InstanceName;
                dstPriority = dstFmu.Priority;
                dstPortName = dstFmu.InputMap[dstPortId];

                flatConnInfo = {
                    'Source': srcFmuName + '.' + srcPortName,
                    'Destination': dstFmuName + '.' + dstPortName,
                    'SrcPriority': srcPriority,
                    'DstPriority': dstPriority
                };

                self.connections.push(flatConnInfo);
            }
        }
    };

    FmiExporter.prototype.followConnsAssignPriority = function (srcFmuPath, srcFmu) {
        var self = this,
            srcFmuName = srcFmu.InstanceName,
            srcFmuOutputs = srcFmu.OutputMap,
            outputIds = Object.keys(srcFmuOutputs),
            srcPriority = srcFmu.Priority,
            dstPriority = srcPriority + 1,
            numberOutputs = outputIds.length,
            i,
            j;

        if (numberOutputs === 0) {
            self.logger.debug(srcFmu.InstanceName + ' has no Outputs.');
            return;
        }

        for (i = 0; i < outputIds.length; i += 1) {
            var outputId = outputIds[i],
                outputName = srcFmuOutputs[outputId],
                connMapKey = srcFmuPath + '/' + outputId;

            if (self.connectionMap.hasOwnProperty(connMapKey) === false) {
                self.logger.debug('No connections leaving from ' + srcFmuName + '.' + outputName);
                continue;
            }

            // Could be multiple connections leaving this port
            var allConnections = self.connectionMap[connMapKey];

            for (j = 0; j < allConnections.length; j += 1) {
                var connectedInput = allConnections[j],
                    dstFmuId = connectedInput.split('/')[0],
                    dstPortId = connectedInput.split('/')[1],
                    dstFmu = self.fmuIdToInfoMap[dstFmuId],
                    dstPortName = dstFmu.InputMap[dstPortId];

                if (dstFmu.Priority < dstPriority) {
                    dstFmu.Priority = dstPriority;
                }

                // dst becomes src, repeat
                self.followConnsAssignPriority(dstFmuId, dstFmu);
            }
        }
    };

    // a Synchronous helper function to get FMU Parameters, Inputs, and Outputs
    FmiExporter.prototype.extractFmuInfo = function (fmuChildren) {
        var self = this,
            i,
            fmuChildNode,
            fmuChildNodePath,
            fmuChildNodeName,
            parameters = {},
            inputMap = {},
            outputMap = {};

        for (i = 0; i < fmuChildren.length; i += 1) {

            fmuChildNode = fmuChildren[i];
            fmuChildNodePath = self.core.getPath(fmuChildNode);
            fmuChildNodeName = self.core.getAttribute(fmuChildNode, 'name');

            if (self.isMetaTypeOf(fmuChildNode, FmuMetaTypes.Parameter)) {
                parameters[fmuChildNodeName] = self.core.getAttribute(fmuChildNode, 'value');

            } else if (self.isMetaTypeOf(fmuChildNode, FmuMetaTypes.Input)) {
                inputMap[fmuChildNodePath] = fmuChildNodeName;

            } else if (self.isMetaTypeOf(fmuChildNode, FmuMetaTypes.Output)) {
                outputMap[fmuChildNodePath] = fmuChildNodeName;
            }
        }

        return {
            Parameters: parameters,
            InputMap: inputMap,
            OutputMap: outputMap
        };
    };

    return FmiExporter;
});

