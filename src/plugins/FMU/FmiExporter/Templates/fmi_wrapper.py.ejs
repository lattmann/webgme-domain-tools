#
# AUTO-GENERATED by FmiExporterPlugin (WebGME)
#

__author__ = 'James Klingler, ISIS Vanderbilt'


from pymodelica import compile_fmu   # JModelica.org's 'pymodelica'
from pyfmi import load_fmu

import logging

log = logging.getLogger()

class FMI_ME(object):

    def __init__(self, model_exchange_config):

        fmu_list = model_exchange_config['FMUs']
        conn_list = model_exchange_config['Connections']
        sim_info = model_exchange_config['SimulationInfo']
        self.sim_start_time = float(sim_info['StartTime'])
        self.sim_stop_time = float(sim_info['StopTime'])
        self.step_size = float(sim_info['StepSize'])
        self.priority_map = dict()
        self.connections = list()

        self.populate_priority_map(fmu_list)

        self.populate_conn_list(conn_list)


    def populate_priority_map(self, fmu_list):

        # Load and initialize the FMUs (parameters and simulation info)
        for fmu_instance_info in fmu_list:
            fmu = FMU(fmu_instance_info, self.sim_start_time)
            priority = fmu.priority
            if priority not in self.priority_map:
                self.priority_map.update({priority: dict()})

            self.priority_map[priority].update({fmu.name: fmu})

    def populate_conn_list(self, conn_list):

        for conn_info in conn_list:

            conn = CONN(conn_info)
            self.connections.append(conn)


class CONN(object):

    def __init__(self, connection_info):

        source = connection_info['Source'].split('.')
        destination = connection_info['Destination'].split('.')

        self.src_fmu = source[0]
        self.src_port = source[-1]
        self.src_value_ref = None
        self.src_priority = connection_info['SrcPriority']
        self.dst_fmu = destination[0]
        self.dst_port = destination[-1]
        self.dst_value_ref = None
        self.dst_priority = connection_info['DstPriority']

class FMU(object):

    def __init__(self, fmu_info, sim_start_time):

        self.name = fmu_info['Name']
        self.priority = fmu_info['Priority']

        fmu_file_path = fmu_info['File']
        self.pyfmi_fmu = load_fmu(fmu_file_path)
        self.set_instance_parameters(fmu_info['Parameters'])
        self.pyfmi_fmu.time = sim_start_time
        self.pyfmi_fmu.initialize()
        self.state_value_refs = self.pyfmi_fmu.get_state_value_references()
        self.time_varying_refs = self.pyfmi_fmu.get_model_time_varying_value_references()[0]
        # self.input_value_refs = self.get_value_refs(fmu_info['Inputs'])
        # self.output_value_refs = self.get_value_refs(fmu_info['Outputs'])
        self.input_names = fmu_info['Inputs']
        self.output_names = fmu_info['Outputs']

    def get_value_refs(self, variable_name_list):

        value_refs = list()

        for var_name in variable_name_list:
            v_ref = self.pyfmi_fmu.get_variable_valueref(var_name)
            value_refs.append(v_ref)

        return value_refs

    def set_instance_parameters(self, parameter_map):

        names = list()
        values = list()

        for p_name, p_value in parameter_map.iteritems():

            # if '*' in p_value:
            #     continue
            #     multiply = p_value.split('*')

            names.append(p_name)
            values.append(p_value)

            #value_type = self.pyfmi_fmu.get_variable_data_type(p_name)
            # this returns an integer, where:
            # 0: Real
            # 1: Integer
            # 2: Boolean
            # 3: ?
            # 4: Enumeration

            #fmu_val_ref = self.pyfmi_fmu.get_variable_valueref(p_name)

            #if value_type in [str, unicode]:
            # if value_type in [str, unicode] and '*' not in p_value:  # hack to ignore formulas
            #     log.info('{0}-{1} is a being treated as a string ({2})'.format(p_name, p_value, value_type))
            #     self.pyfmi_fmu.set_string(fmu_val_ref, str(p_value))
            # elif value_type is int:
            #     log.info('{0}-{1} is a being treated as an integer ({2})'.format(p_name, p_value, value_type))
            #     self.pyfmi_fmu.set_integer(fmu_val_ref, int(p_value))
            # elif value_type is float:
            #     log.info('{0}-{1} is a being treated as a float ({2})'.format(p_name, p_value, value_type))
            #     self.pyfmi_fmu.set_real(fmu_val_ref, float(p_value))
            # elif value_type is bool:
            #     log.info('{0}-{1} is a being treated as a bool ({2})'.format(p_name, p_value, value_type))
            #     self.pyfmi_fmu.set_boolean(fmu_val_ref, bool(p_value))

        self.pyfmi_fmu.set(names, values)

    # def get_continuous_states(self):
    #
    #     self.states = self.pyfmi_fmu.continuous_states     # update 'this' fmu's states
    #     return  self.states                          # expose them to the caller
    #
    # def get_state_derivatives(self):
    #
    #     self.derivatives = self.pyfmi_fmu.get_derivatives()     # update 'this' fmu's derivatives
    #     return self.derivatives                           # expose them to the caller
    #
    # def get_nominal_state_values(self):
    #
    #     self.nominal_state_values = self.pyfmi_fmu.nominal_continuous_states     # update 'this' fmu's derivatives
    #     return self.nominal_state_values
