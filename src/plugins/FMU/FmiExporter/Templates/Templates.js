/* Generated file based on ejs templates */
define([], function() {
    return {
    "fmi_wrapper.py.ejs": "#\r\n# AUTO-GENERATED by FmiExporterPlugin (WebGME)\r\n#\r\n\r\n__author__ = 'James Klingler, ISIS Vanderbilt'\r\n\r\n\r\nfrom pymodelica import compile_fmu   # JModelica.org's 'pymodelica'\r\nfrom pyfmi import load_fmu\r\n\r\nimport logging\r\n\r\nlog = logging.getLogger()\r\n\r\nclass FMI_ME(object):\r\n\r\n    def __init__(self, model_exchange_config):\r\n    \r\n        fmu_info_map = model_exchange_config['FMUs']\r\n        sim_info = model_exchange_config['SimulationInfo']\r\n\r\n        self.conn_map = model_exchange_config['Connections']        \r\n        self.fmu_map = dict()\r\n        self.priority_map = model_exchange_config['PriorityMap']\r\n        self.sim_start_time = float(sim_info['StartTime'])\r\n        self.sim_stop_time = float(sim_info['StopTime'])\r\n        self.step_size = float(sim_info['StepSize'])\r\n        \r\n        self.load_fmus(fmu_info_map)\r\n\r\n    def load_fmus(self, fmu_info_map):\r\n\r\n        # Load and initialize the FMUs (parameters and simulation info)\r\n        for fmu_path, fmu_instance_info in fmu_info_map.iteritems():\r\n            fmu = FMU(fmu_instance_info, self.sim_start_time)\r\n            self.fmu_map[fmu_path] = fmu\r\n\r\n            \r\nclass FMU(object):\r\n\r\n    def __init__(self, fmu_info, sim_start_time):\r\n\r\n        self.name = fmu_info['InstanceName']\r\n        fmu_file_path = fmu_info['File']\r\n        self.pyfmi_fmu = load_fmu(fmu_file_path)\r\n        self.set_instance_parameters(fmu_info['Parameters'])\r\n        self.pyfmi_fmu.time = sim_start_time\r\n        self.pyfmi_fmu.initialize()\r\n        self.state_value_refs = self.pyfmi_fmu.get_state_value_references()\r\n        self.time_varying_refs = self.pyfmi_fmu.get_model_time_varying_value_references()[0]\r\n        \r\n        self.input_map = self.make_inputs(fmu_info['Inputs'])\r\n        self.output_map = self.make_outputs(fmu_info['Outputs'])\r\n\r\n\r\n    def make_inputs(self, path_name_map):\r\n\r\n        input_map = dict()\r\n    \r\n        for path, name in path_name_map.iteritems():\r\n            v_ref = self.pyfmi_fmu.get_variable_valueref(name)\r\n            input = INPUT(name, v_ref, self.name)\r\n            input_map[path] = input\r\n\r\n        return input_map\r\n\r\n    def make_outputs(self, path_name_map):\r\n\r\n        output_map = dict()\r\n    \r\n        for path, name in path_name_map.iteritems():\r\n            v_ref = self.pyfmi_fmu.get_variable_valueref(name)\r\n            output = OUTPUT(name, v_ref, self.name)\r\n            output_map[path] = output\r\n\r\n        return output_map\r\n        \r\n    def set_instance_parameters(self, parameter_map):\r\n\r\n        names = list()\r\n        values = list()\r\n\r\n        for p_name, p_value in parameter_map.iteritems():\r\n\r\n            # if '*' in p_value:\r\n            #     continue\r\n            #     multiply = p_value.split('*')\r\n\r\n            names.append(p_name)\r\n            values.append(p_value)\r\n\r\n        self.pyfmi_fmu.set(names, values)\r\n\r\nclass INPUT(object):\r\n\r\n    def __init__(self, input_name, value_ref, fmu_name):\r\n    \r\n        self.name = input_name\r\n        self.value_ref = value_ref\r\n        self.csv_row_header = fmu_name + '.' + input_name\r\n        \r\nclass OUTPUT(object):\r\n\r\n    def __init__(self, output_name, value_ref, fmu_name):\r\n    \r\n        self.name = output_name\r\n        self.value_ref = value_ref\r\n        self.csv_row_header = fmu_name + '.' + output_name",
    "jmodelica_model_exchange.py.ejs": "#\r\n# GENERATED by FmiExporterPlugin (WebGME)\r\n#\r\n\r\n__author__ = 'James Klingler - ISIS Vanderbilt'\r\n\r\nimport os\r\nimport sys\r\nimport json\r\nimport csv\r\nimport logging\r\nimport zipfile\r\ntry:\r\n    import zlib\r\n    zip_compression = zipfile.ZIP_DEFLATED\r\nexcept:\r\n    zip_compression = zipfile.ZIP_STORED\r\n\r\nimport matplotlib.pyplot as plt\r\nimport numpy as N\r\n\r\nfrom fmi_wrapper import FMI_ME, FMU\r\n\r\ntry:\r\n    from pymodelica import compile_fmu   # JModelica.org's 'pymodelica'\r\n    from pyfmi import load_fmu\r\nexcept:\r\n    import_error_msg = \"JModelica 'pymodelica' or 'pyfmi' module was not \" \\\r\n                       \"found. Make sure you have set all the environment \" \\\r\n                       \"variables from C:\\JModelica.org-1.12\\setenv.bat\"\r\n    print import_error_msg\r\n\r\n# Set up the Option parser\r\nfrom optparse import OptionParser\r\n\r\nparser = OptionParser()\r\nparser.add_option(\"-c\",\r\n                  \"--config\",\r\n                  dest=\"model_exchange_config_file\",\r\n                  help=\"Path to the model exchange configuration file.\")\r\n\r\n                  \r\nlogger = logging.getLogger()\r\nlogger.setLevel(logging.DEBUG)\r\n\r\n# Create a file handler with a debug log level\r\nfh = logging.FileHandler(\"jmodelica_model_exchange_py.log\")\r\nfh.setLevel(logging.DEBUG)\r\n\r\n# create console handler with a higher log level\r\nch = logging.StreamHandler()\r\nch.setLevel(logging.WARNING)\r\n\r\n# create formatter and add it to the handlers\r\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\r\nfh.setFormatter(formatter)\r\nch.setFormatter(formatter)\r\n\r\n# add the handlers to the logger\r\nlogger.addHandler(fh)\r\nlogger.addHandler(ch)\r\n\r\ndef read_model_exchange_config(model_exchange_config_file):\r\n\r\n    logger.debug(\"Enter 'read_model_exchange_config({0})'\".format(model_exchange_config_file))\r\n\r\n    with open(model_exchange_config_file, 'r') as f_in:\r\n        config_dict = json.load(f_in)\r\n\r\n    return config_dict\r\n    \r\n\r\ndef run_explicit_euler(fmi_me_object):\r\n\r\n    logger.debug(\"Enter 'run_explicit_euler'\")\r\n\r\n    # All FMUs have been loaded and initialized\r\n\r\n    sim_start_time = fmi_me_object.sim_start_time\r\n    sim_end_time = fmi_me_object.sim_stop_time\r\n    integration_step_size = fmi_me_object.step_size\r\n\r\n    # Create the time-series & results variables and set the initial values\r\n    # Also, initialize the terminate simulation var\r\n    #time_for_result = np.array([sim_start_time])\r\n    time_for_result = [sim_start_time]\r\n\r\n    results_data = dict()\r\n    terminate_simulation = list()\r\n\r\n    # initialize result arrays for all state variables\r\n    for fmu_path, fmu in fmi_me_object.fmu_map.iteritems():\r\n    \r\n        fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)\r\n        results_data.update({fmu.name: [fmu_result]})\r\n        terminate_simulation.append(fmu.pyfmi_fmu.get_event_info().terminateSimulation)\r\n\r\n    i = 0\r\n    #index_for_result = np.array([i])\r\n    index_for_result = [i]\r\n    time_at_step_i = sim_start_time  # initialize the 'time' variable\r\n    t_next = sim_end_time\r\n\r\n    while time_at_step_i < sim_end_time and not True in terminate_simulation:\r\n\r\n        # Get the time_increment size\r\n        t_increment = min(integration_step_size, t_next-time_at_step_i)\r\n\r\n        # Increment the index and the time\r\n        i += 1\r\n        time_at_step_i = time_at_step_i + t_increment\r\n        \r\n        logger.debug(\"Solving system for at t={0}\".format(time_at_step_i))\r\n        \r\n        for i in range(len(fmi_me_object.priority_map)):\r\n           \r\n            fmu_path = fmi_me_object.priority_map[str(i + 1)]\r\n            fmu = fmi_me_object.fmu_map[fmu_path]\r\n            \r\n            logger.debug(\"Solving {0}\".format(fmu.name))\r\n\r\n            # Get existing event indicators\r\n            event_indicators = fmu.pyfmi_fmu.get_event_indicators()\r\n\r\n            # Get existing states and compute derivatives of the FMU\r\n            x_bar = fmu.pyfmi_fmu.continuous_states\r\n            x_dot = fmu.pyfmi_fmu.get_derivatives()\r\n\r\n            # Set time of the FMU\r\n            fmu.pyfmi_fmu.time = time_at_step_i\r\n\r\n            # Compute new states and set them\r\n            x_bar = x_bar + t_increment*x_dot\r\n            fmu.pyfmi_fmu.continuous_states = x_bar\r\n\r\n            ########### Check for Events ###############\r\n            \r\n            # Get new event indicators\r\n            event_indicators_new = fmu.pyfmi_fmu.get_event_indicators()\r\n\r\n            # Inform FMUs of the step and check for a step event (returns True/False)\r\n            step_event = fmu.pyfmi_fmu.completed_integrator_step()\r\n\r\n            # Check for time and state events (time events are 'predictable', state events are not necessarily so)\r\n            time_event  = abs(time_at_step_i-t_next) <= 1.e-10  # this one checks for the end (?)\r\n            state_event = True if True in ((event_indicators_new>0.0) != (event_indicators>0.0)) else False\r\n\r\n            # Handle any events\r\n            if step_event or time_event or state_event:\r\n\r\n                event_info = fmu.pyfmi_fmu.get_event_info()\r\n                event_info.iterationConverged = False\r\n\r\n                # Event iteration\r\n                while event_info.iterationConverged == False:\r\n                    fmu.pyfmi_fmu.event_update(intermediateResult=True) #Stops after each event iteration\r\n                    event_info = fmu.pyfmi_fmu.get_event_info()\r\n\r\n                    #Retrieve solutions (if needed)\r\n                    if event_info.iterationConverged == False:\r\n                        # fmu.get_real, get_integer, get_boolean,\r\n                        # get_string(valueref)\r\n                        pass\r\n\r\n                # Check if the event affected the state values and if so sets them\r\n                if event_info.stateValuesChanged:\r\n                    x_bar = fmu.pyfmi_fmu.continuous_states\r\n\r\n                # Get new nominal values.\r\n                if event_info.stateValueReferencesChanged:\r\n                    atol = 0.01*rtol*fmu.pyfmi_fmu.nominal_continuous_states\r\n\r\n                # Check for new time event\r\n                if event_info.upcomingTimeEvent:\r\n                    t_next = min(event_info.nextEventTime, sim_end_time)\r\n                else:\r\n                    t_next = sim_end_time\r\n\r\n            ##########################\r\n\r\n            fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)\r\n            result_array = results_data[fmu.name]\r\n            result_array.append(fmu_result)\r\n\r\n            # Propagate output values\r\n            for output_path, output_object in fmu.output_map.iteritems():\r\n                output_value = fmu.pyfmi_fmu.get_real(output_object.value_ref)\r\n            \r\n                if output_path in fmi_me_object.conn_map:\r\n                    for target_input_path in fmi_me_object.conn_map[output_path]:\r\n                        target_fmu_path = get_parent_fmu_path(target_input_path)\r\n                        target_fmu = fmi_me_object.fmu_map[target_fmu_path]\r\n                        input_value_ref = target_fmu.input_map[target_input_path].value_ref\r\n                        target_fmu.pyfmi_fmu.set_real(input_value_ref, output_value)\r\n\r\n        time_for_result.append(time_at_step_i)\r\n    \r\n    #  Save results\r\n    logger.debug(\"Saving .csv and.svg files\")   \r\n\r\n    save_results(fmi_me_object.fmu_map, time_for_result, results_data)\r\n    \r\n    \r\ndef save_results(fmu_map, time_for_result, results_data):\r\n\r\n    if not os.path.isdir('Results'):\r\n        os.mkdir('Results')\r\n        \r\n    os.chdir('Results')\r\n    \r\n    name_plus_data = ['time'] + time_for_result\r\n    \r\n    with open('results.csv', 'ab') as result_file:\r\n        csv_writer = csv.writer(result_file)\r\n        csv_writer.writerow(name_plus_data)\r\n\r\n    plot_index = 1\r\n\r\n    webgme_path_2_plot_path = dict()\r\n\r\n    for fmu_path, fmu in fmu_map.iteritems():\r\n    \r\n        plt.figure(plot_index)\r\n        plt.title(fmu.name + ' - Time-changing Variables')\r\n        plt.xlabel('Time (s)')\r\n        plot_index += 1\r\n    \r\n        # Save all time-varying results to csv\r\n        for value_ref in fmu.time_varying_refs:\r\n        \r\n            value_ref_index = fmu.time_varying_refs.index(value_ref)\r\n            variable_name = fmu.pyfmi_fmu.get_variable_by_valueref(value_ref)\r\n            full_name = fmu.name + '.' + variable_name\r\n            data_series = N.array(results_data[fmu.name])[:,value_ref_index]\r\n            data_series_list = data_series.tolist()\r\n            plt.plot(time_for_result, data_series, label=variable_name)\r\n            name_plus_data_series = [full_name] + data_series_list\r\n            with open('results.csv', 'ab') as result_file:\r\n                csv_writer = csv.writer(result_file)\r\n                csv_writer.writerow(name_plus_data_series)\r\n\r\n        plt.legend(loc=0)\r\n        plot_name = fmu.name + '_All.svg'\r\n        plt.savefig(plot_name)\r\n        plt.close()\r\n        \r\n        webgme_path_2_plot_path[fmu_path] = plot_name\r\n                \r\n        for webgme_path, input_object in fmu.input_map.iteritems():\r\n        \r\n            plt.figure(plot_index)\r\n            plt.title(input_object.csv_row_header)\r\n            plt.xlabel('Time (s)')\r\n            plot_index += 1\r\n        \r\n            input_valueref = input_object.value_ref\r\n            var_to_plot_index = fmu.time_varying_refs.index(input_valueref)\r\n            data_series = N.array(results_data[fmu.name])[:,var_to_plot_index]\r\n            plt.plot(time_for_result, data_series, label=input_object.name)\r\n            \r\n            plot_name = fmu.name + '_' + input_object.name + '.svg'\r\n            plt.savefig(plot_name)\r\n            plt.close()\r\n            \r\n            webgme_path_2_plot_path[webgme_path] = plot_name\r\n            \r\n        for webgme_path, output_object in fmu.output_map.iteritems():\r\n        \r\n            plt.figure(plot_index)\r\n            plt.title(output_object.csv_row_header)\r\n            plt.xlabel('Time (s)')\r\n            plot_index += 1\r\n        \r\n            output_valueref = output_object.value_ref\r\n            var_to_plot_index = fmu.time_varying_refs.index(output_valueref)\r\n            data_series = N.array(results_data[fmu.name])[:,var_to_plot_index]\r\n            plt.plot(time_for_result, data_series, label=output_object.name)\r\n\r\n            plot_name = fmu.name + '_' + output_object.name + '.svg'\r\n            plt.savefig(plot_name)\r\n            plt.close()\r\n            \r\n            webgme_path_2_plot_path[webgme_path] = plot_name\r\n        \r\n    with open('plot_map.json', 'wb') as plot_map_file:\r\n        json.dump(webgme_path_2_plot_path, plot_map_file)\r\n        \r\n    os.chdir('..')\r\n    \r\n    <!--with zipfile.ZipFile('Results.zip', 'w', zip_compression) as results_zip:-->\r\n        <!--os.chdir('Results')-->\r\n\r\n        <!--results_zip.write('plot_map.json')-->\r\n        <!--results_zip.write('results.csv')-->\r\n        <!---->\r\n        <!--for webgme_path, file_name in webgme_path_2_plot_path.iteritems():-->\r\n            <!--results_zip.write(file_name)-->\r\n            <!---->\r\n        <!--os.chdir('..')-->\r\n    \r\n\r\ndef get_parent_fmu_path(fmu_input_path):\r\n\r\n    input_split_path = fmu_input_path.split('/')\r\n    parent_split_path = input_split_path[:-1]\r\n    parent_fmu_path = '/'.join(parent_split_path)\r\n    \r\n    return parent_fmu_path\r\n    \r\n            \r\ndef main():\r\n\r\n    logger.debug(\"===================================\")\r\n    logger.debug(\"RUNNING jmodelica_model_exchange.py\")\r\n    logger.debug(\"===================================\")\r\n\r\n    (options, args) = parser.parse_args()\r\n\r\n    config_file = r'.\\\\model_exchange_config.json'\r\n\r\n    if options.model_exchange_config_file:\r\n        config_file = options.model_exchange_config_file\r\n\r\n    me_config = read_model_exchange_config(config_file)\r\n\r\n    fmi_object = FMI_ME(me_config)\r\n\r\n    run_explicit_euler(fmi_object)\r\n\r\n\r\nif __name__ == '__main__':\r\n\r\n    root_dir = os.getcwd()\r\n\r\n    try:\r\n        main()\r\n    except:\r\n        import traceback\r\n        trace = traceback.format_exc()\r\n\r\n        logger.error(trace)\r\n        logger.info('See jmodelica_model_exchange_py.log for details.')\r\n        \r\n        sys.exit(2)\r\n",
    "ReadMe.txt.ejs": "NOTE: This requires JModelica v1.12 to be installed at \"C:\\JModelica.org-1.12\", and 'system' Python at \"C:\\Python27\\python.exe\"\r\n\r\n1) Open a command window\r\n2) run 'run_jmodelica_model_exchange.cmd' \r\n    - input/output plots should be generated for all FMUs\r\n\r\n- All the necessary FMUs are here in the directory\r\n- The model_exchange_config.json explains how they should be connected\r\n- jmodelica_model_exchange.py reads the config file and runs 'explicit euler' model exchange simulation using JModelica\r\n",
    "run_jmodelica_model_exchange.cmd.ejs": ":: Use System Python (which should have access to JModelica) to run the FMI_ME example\r\necho off\r\npushd %~dp0\r\ncall C:\\JModelica.org-1.12\\setenv.bat\r\n\"C:\\Python27\\python.exe\" .\\\\jmodelica_model_exchange.py .\\\\model_exchange_config.json\r\npopd"
}});