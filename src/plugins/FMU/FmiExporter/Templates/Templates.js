/* Generated file based on ejs templates */
define([], function() {
    return {
    "fmi_wrapper.py.ejs": "#\r\n# AUTO-GENERATED by FmiExporterPlugin (WebGME)\r\n#\r\n\r\n__author__ = 'James Klingler, ISIS Vanderbilt'\r\n\r\n\r\nfrom pymodelica import compile_fmu   # JModelica.org's 'pymodelica'\r\nfrom pyfmi import load_fmu\r\n\r\nimport logging\r\n\r\nlog = logging.getLogger()\r\n\r\nclass FMI_ME(object):\r\n\r\n    def __init__(self, model_exchange_config):\r\n\r\n        fmu_list = model_exchange_config['FMUs']\r\n        conn_list = model_exchange_config['Connections']\r\n        sim_info = model_exchange_config['SimulationInfo']\r\n        self.sim_start_time = float(sim_info['StartTime'])\r\n        self.sim_stop_time = float(sim_info['StopTime'])\r\n        self.step_size = float(sim_info['StepSize'])\r\n        self.priority_map = dict()\r\n        self.connections = list()\r\n\r\n        self.populate_priority_map(fmu_list)\r\n\r\n        self.populate_conn_list(conn_list)\r\n\r\n\r\n    def populate_priority_map(self, fmu_list):\r\n\r\n        # Load and initialize the FMUs (parameters and simulation info)\r\n        for fmu_instance_info in fmu_list:\r\n            fmu = FMU(fmu_instance_info, self.sim_start_time)\r\n            priority = fmu.priority\r\n            if priority not in self.priority_map:\r\n                self.priority_map.update({priority: dict()})\r\n\r\n            self.priority_map[priority].update({fmu.name: fmu})\r\n\r\n    def populate_conn_list(self, conn_list):\r\n\r\n        for conn_info in conn_list:\r\n\r\n            conn = CONN(conn_info)\r\n            self.connections.append(conn)\r\n\r\n\r\nclass CONN(object):\r\n\r\n    def __init__(self, connection_info):\r\n\r\n        source = connection_info['Source'].split('.')\r\n        destination = connection_info['Destination'].split('.')\r\n\r\n        self.src_fmu = source[0]\r\n        self.src_port = source[-1]\r\n        self.src_value_ref = None\r\n        self.src_priority = connection_info['SrcPriority']\r\n        self.dst_fmu = destination[0]\r\n        self.dst_port = destination[-1]\r\n        self.dst_value_ref = None\r\n        self.dst_priority = connection_info['DstPriority']\r\n\r\nclass FMU(object):\r\n\r\n    def __init__(self, fmu_info, sim_start_time):\r\n\r\n        self.name = fmu_info['InstanceName']\r\n        self.priority = fmu_info['Priority']\r\n\r\n        fmu_file_path = fmu_info['File']\r\n        self.pyfmi_fmu = load_fmu(fmu_file_path)\r\n        self.set_instance_parameters(fmu_info['Parameters'])\r\n        self.pyfmi_fmu.time = sim_start_time\r\n        self.pyfmi_fmu.initialize()\r\n        self.state_value_refs = self.pyfmi_fmu.get_state_value_references()\r\n        self.time_varying_refs = self.pyfmi_fmu.get_model_time_varying_value_references()[0]\r\n        # self.input_value_refs = self.get_value_refs(fmu_info['Inputs'])\r\n        # self.output_value_refs = self.get_value_refs(fmu_info['Outputs'])\r\n        self.input_names = fmu_info['Inputs']\r\n        self.output_names = fmu_info['Outputs']\r\n\r\n    def get_value_refs(self, variable_name_list):\r\n\r\n        value_refs = list()\r\n\r\n        for var_name in variable_name_list:\r\n            v_ref = self.pyfmi_fmu.get_variable_valueref(var_name)\r\n            value_refs.append(v_ref)\r\n\r\n        return value_refs\r\n\r\n    def set_instance_parameters(self, parameter_map):\r\n\r\n        names = list()\r\n        values = list()\r\n\r\n        for p_name, p_value in parameter_map.iteritems():\r\n\r\n            # if '*' in p_value:\r\n            #     continue\r\n            #     multiply = p_value.split('*')\r\n\r\n            names.append(p_name)\r\n            values.append(p_value)\r\n\r\n            #value_type = self.pyfmi_fmu.get_variable_data_type(p_name)\r\n            # this returns an integer, where:\r\n            # 0: Real\r\n            # 1: Integer\r\n            # 2: Boolean\r\n            # 3: ?\r\n            # 4: Enumeration\r\n\r\n            #fmu_val_ref = self.pyfmi_fmu.get_variable_valueref(p_name)\r\n\r\n            #if value_type in [str, unicode]:\r\n            # if value_type in [str, unicode] and '*' not in p_value:  # hack to ignore formulas\r\n            #     log.info('{0}-{1} is a being treated as a string ({2})'.format(p_name, p_value, value_type))\r\n            #     self.pyfmi_fmu.set_string(fmu_val_ref, str(p_value))\r\n            # elif value_type is int:\r\n            #     log.info('{0}-{1} is a being treated as an integer ({2})'.format(p_name, p_value, value_type))\r\n            #     self.pyfmi_fmu.set_integer(fmu_val_ref, int(p_value))\r\n            # elif value_type is float:\r\n            #     log.info('{0}-{1} is a being treated as a float ({2})'.format(p_name, p_value, value_type))\r\n            #     self.pyfmi_fmu.set_real(fmu_val_ref, float(p_value))\r\n            # elif value_type is bool:\r\n            #     log.info('{0}-{1} is a being treated as a bool ({2})'.format(p_name, p_value, value_type))\r\n            #     self.pyfmi_fmu.set_boolean(fmu_val_ref, bool(p_value))\r\n\r\n        self.pyfmi_fmu.set(names, values)\r\n\r\n    # def get_continuous_states(self):\r\n    #\r\n    #     self.states = self.pyfmi_fmu.continuous_states     # update 'this' fmu's states\r\n    #     return  self.states                          # expose them to the caller\r\n    #\r\n    # def get_state_derivatives(self):\r\n    #\r\n    #     self.derivatives = self.pyfmi_fmu.get_derivatives()     # update 'this' fmu's derivatives\r\n    #     return self.derivatives                           # expose them to the caller\r\n    #\r\n    # def get_nominal_state_values(self):\r\n    #\r\n    #     self.nominal_state_values = self.pyfmi_fmu.nominal_continuous_states     # update 'this' fmu's derivatives\r\n    #     return self.nominal_state_values\r\n",
    "jmodelica_model_exchange.py.ejs": "#\r\n# AUTO-GENERATED by FmiExporterPlugin (WebGME)\r\n#\r\n\r\n__author__ = 'James Klingler'\r\n\r\nimport os\r\nimport sys\r\nimport json\r\nimport logging\r\nimport pylab as P\r\nimport matplotlib.pyplot as plt\r\nimport numpy as N\r\n\r\nfrom fmi_wrapper import FMI_ME, FMU\r\n\r\ntry:\r\n    from pymodelica import compile_fmu   # JModelica.org's 'pymodelica'\r\n    from pyfmi import load_fmu\r\nexcept:\r\n    import_error_msg = \"JModelica 'pymodelica' or 'pyfmi' module was not \" \\\r\n                       \"found. Make sure you have set all the environment \" \\\r\n                       \"variables from C:\\JModelica.org-1.12\\setenv.bat\"\r\n    print import_error_msg\r\n\r\n# Set up the Option parser\r\nfrom optparse import OptionParser\r\n\r\nparser = OptionParser()\r\nparser.add_option(\"-c\",\r\n                  \"--config\",\r\n                  dest=\"model_exchange_config_file\",\r\n                  help=\"Path to the model exchange configuration file.\")\r\n\r\n# Set up logger to write to 'filename'\r\nlogging.basicConfig(filename= \"jmodelica_model_exchange_py.log\",\r\n                    level=logging.DEBUG,\r\n                    format=\"%(asctime)s %(levelname)s: %(message)s\",\r\n                    datefmt=\"%Y-%m-%d %H:%M:%S\")\r\n\r\n\r\ndef read_model_exchange_config(model_exchange_config_file):\r\n\r\n    with open(model_exchange_config_file, 'r') as f_in:\r\n        config_dict = json.load(f_in)\r\n\r\n    return config_dict\r\n\r\ndef run_explicit_euler(fmi_me_object):\r\n\r\n    # All FMUs have been loaded and initialized\r\n\r\n    sim_start_time = fmi_me_object.sim_start_time\r\n    sim_end_time = fmi_me_object.sim_stop_time\r\n    integration_step_size = fmi_me_object.step_size\r\n\r\n    # Create the time-series & results variables and set the initial values\r\n    # Also, initialize the terminate simulation var\r\n    #time_for_result = np.array([sim_start_time])\r\n    time_for_result = [sim_start_time]\r\n\r\n    results_data = dict()\r\n    terminate_simulation = list()\r\n\r\n    # initialize result arrays for all state vars\r\n    for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():\r\n        for fmu_name, fmu in fmu_map.iteritems():\r\n            fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)\r\n            results_data.update({fmu.name: [fmu_result]})\r\n            terminate_simulation.append(fmu.pyfmi_fmu.get_event_info().terminateSimulation)\r\n\r\n    i = 0\r\n    #index_for_result = np.array([i])\r\n    index_for_result = [i]\r\n    time_at_step_i = sim_start_time  # initialize the 'time' variable\r\n    t_next = sim_end_time\r\n\r\n    while time_at_step_i < sim_end_time and not True in terminate_simulation:\r\n\r\n        # Get the time_increment size\r\n        t_increment = min(integration_step_size, t_next-time_at_step_i)\r\n\r\n        # Increment the index and the time\r\n        i += 1\r\n        time_at_step_i = time_at_step_i + t_increment\r\n\r\n        for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():\r\n\r\n            this_priority = priority_level\r\n\r\n            # Solve all 'this_priority' fmus for this time step\r\n            for fmu_name, fmu in fmu_map.iteritems():\r\n\r\n                # Get existing event indicators\r\n                event_indicators = fmu.pyfmi_fmu.get_event_indicators()\r\n\r\n                # Get existing states and compute derivatives of the FMU\r\n                x_bar = fmu.pyfmi_fmu.continuous_states\r\n                x_dot = fmu.pyfmi_fmu.get_derivatives()\r\n\r\n                # Set time of the FMU\r\n                fmu.pyfmi_fmu.time = time_at_step_i\r\n\r\n                # Compute new states and set them\r\n                x_bar = x_bar + t_increment*x_dot\r\n                fmu.pyfmi_fmu.continuous_states = x_bar\r\n\r\n                ##########################\r\n                # Get new event indicators\r\n                event_indicators_new = fmu.pyfmi_fmu.get_event_indicators()\r\n\r\n                # Inform FMUs of the step and check for a step event (returns True/False)\r\n                step_event = fmu.pyfmi_fmu.completed_integrator_step()\r\n\r\n                # Check for time and state events  # time events are 'predictable', state events are not necessarily so.\r\n                time_event  = abs(time_at_step_i-t_next) <= 1.e-10  # this one checks for the end (?)\r\n                state_event = True if True in ((event_indicators_new>0.0) != (event_indicators>0.0)) else False\r\n\r\n                # Handle any events\r\n                if step_event or time_event or state_event:\r\n\r\n                    event_info = fmu.pyfmi_fmu.get_event_info()\r\n                    event_info.iterationConverged = False\r\n\r\n                    # Event iteration\r\n                    while event_info.iterationConverged == False:\r\n                        fmu.pyfmi_fmu.event_update(intermediateResult=True) #Stops after each event iteration\r\n                        event_info = fmu.pyfmi_fmu.get_event_info()\r\n\r\n                        #Retrieve solutions (if needed)\r\n                        if event_info.iterationConverged == False:\r\n                            #bouncing_fmu.get_real, get_integer, get_boolean,\r\n                            # get_string(valueref)\r\n                            pass\r\n\r\n                    # Check if the event affected the state values and if so sets them\r\n                    if event_info.stateValuesChanged:\r\n                        x_bar = fmu.pyfmi_fmu.continuous_states\r\n\r\n                    # Get new nominal values.\r\n                    if event_info.stateValueReferencesChanged:\r\n                        atol = 0.01*rtol*fmu.pyfmi_fmu.nominal_continuous_states\r\n\r\n                    # Check for new time event\r\n                    if event_info.upcomingTimeEvent:\r\n                        t_next = min(event_info.nextEventTime, sim_end_time)\r\n                    else:\r\n                        t_next = sim_end_time\r\n\r\n                ##########################\r\n\r\n                fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)\r\n                result_array = results_data[fmu_name]\r\n                result_array.append(fmu_result)\r\n                # results_data.update({fmu.name: result_array})\r\n\r\n            # Propogate values for 'this_priority'\r\n            for conn in fmi_me_object.connections:\r\n                if conn.src_priority == this_priority:\r\n                    src_fmu = fmu_map[conn.src_fmu]\r\n                    conn.src_value_ref = src_fmu.pyfmi_fmu.get_variable_valueref(conn.src_port)\r\n                    value = src_fmu.pyfmi_fmu.get_real(conn.src_value_ref)\r\n                    dst_fmu = fmi_me_object.priority_map[conn.dst_priority][conn.dst_fmu]\r\n                    conn.dst_value_ref = dst_fmu.pyfmi_fmu.get_variable_valueref(conn.dst_port)\r\n                    dst_fmu.pyfmi_fmu.set_real(conn.dst_value_ref, value)\r\n\r\n        time_for_result.append(time_at_step_i)\r\n\r\n\r\n    #  PLOTTING\r\n    plot_index = 1\r\n\r\n    if not os.path.isdir('Plots'):\r\n        os.mkdir('Plots')\r\n\r\n    for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():\r\n        for fmu_name, fmu in fmu_map.iteritems():\r\n            plt.figure(plot_index)\r\n            plt.title(fmu_name)\r\n            plt.xlabel('Time (s)')\r\n            for input_name in fmu.input_names:\r\n                input_valueref = fmu.pyfmi_fmu.get_variable_valueref(input_name)\r\n                var_to_plot_index = fmu.time_varying_refs.index(input_valueref)\r\n                plt.plot(time_for_result, N.array(results_data[fmu_name])[:,var_to_plot_index], label=input_name)  # Inputs in blue\r\n            for output_name in fmu.output_names:\r\n                output_valueref = fmu.pyfmi_fmu.get_variable_valueref(output_name)\r\n                var_to_plot_index = fmu.time_varying_refs.index(output_valueref)\r\n                plt.plot(time_for_result, N.array(results_data[fmu_name])[:,var_to_plot_index], label=output_name)  # Outputs in red\r\n\r\n            plt.legend(loc=0)\r\n            plot_name = fmu_name + '_InputsOutputs.svg'\r\n            plot_path = os.path.join('Plots', plot_name)\r\n            plt.savefig(plot_path)\r\n            plt.close()\r\n            plot_index += 1\r\n\r\n\r\ndef main():\r\n\r\n    (options, args) = parser.parse_args()\r\n\r\n    config_file = r'.\\\\model_exchange_config.json'\r\n\r\n    if options.model_exchange_config_file:\r\n        config_file = options.model_exchange_config_file\r\n\r\n    me_config = read_model_exchange_config(config_file)\r\n\r\n    fmi_object = FMI_ME(me_config)\r\n\r\n    run_explicit_euler(fmi_object)\r\n\r\n\r\nif __name__ == '__main__':\r\n    log = logging.getLogger()\r\n    root_dir = os.getcwd()\r\n\r\n    try:\r\n        main()\r\n    except:\r\n        import traceback\r\n        trace = traceback.format_exc()\r\n\r\n        failed_file = os.path.join(root_dir,\r\n                                   'jmodelica_model_exchange_FAILED.txt')\r\n\r\n        with open(failed_file, 'wb') as f_out:\r\n            f_out.write(trace)\r\n        log.error('See {0} for details.'.format(failed_file))\r\n        sys.exit(2)\r\n",
    "ReadMe.txt.ejs": "NOTE: This requires JModelica v1.12 to be installed at \"C:\\JModelica.org-1.12\", and 'system' Python at \"C:\\Python27\\python.exe\"\r\n\r\n1) Open a command window\r\n2) run 'run_jmodelica_model_exchange.cmd' \r\n    - input/output plots should be generated for all FMUs\r\n\r\n- All the necessary FMUs are here in the directory\r\n- The model_exchange_config.json explains how they should be connected\r\n- jmodelica_model_exchange.py reads the config file and runs 'explicit euler' model exchange simulation using JModelica\r\n",
    "run_jmodelica_model_exchange.cmd.ejs": ":: Use System Python (which should have access to JModelica) to run the FMI_ME example\r\necho off\r\npushd %~dp0\r\ncall C:\\JModelica.org-1.12\\setenv.bat\r\n\"C:\\Python27\\python.exe\" .\\\\jmodelica_model_exchange.py .\\\\model_exchange_config.json\r\npopd"
}});