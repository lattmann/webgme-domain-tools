#
# AUTO-GENERATED by FmiExporterPlugin (WebGME)
#

__author__ = 'James Klingler'

import os
import sys
import json
import csv
import logging
import pylab as P
import matplotlib.pyplot as plt
import numpy as N

from fmi_wrapper import FMI_ME, FMU

try:
    from pymodelica import compile_fmu   # JModelica.org's 'pymodelica'
    from pyfmi import load_fmu
except:
    import_error_msg = "JModelica 'pymodelica' or 'pyfmi' module was not " \
                       "found. Make sure you have set all the environment " \
                       "variables from C:\JModelica.org-1.12\setenv.bat"
    print import_error_msg

# Set up the Option parser
from optparse import OptionParser

parser = OptionParser()
parser.add_option("-c",
                  "--config",
                  dest="model_exchange_config_file",
                  help="Path to the model exchange configuration file.")

                  
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

# Create a file handler with a debug log level
fh = logging.FileHandler("jmodelica_model_exchange_py.log")
fh.setLevel(logging.DEBUG)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.WARNING)

# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
ch.setFormatter(formatter)

# add the handlers to the logger
logger.addHandler(fh)
logger.addHandler(ch)

def read_model_exchange_config(model_exchange_config_file):

    logger.debug("Enter 'read_model_exchange_config({0})'".format(model_exchange_config_file))

    with open(model_exchange_config_file, 'r') as f_in:
        config_dict = json.load(f_in)

    return config_dict

def run_explicit_euler(fmi_me_object):

    logger.debug("Enter 'run_explicit_euler'")

    # All FMUs have been loaded and initialized

    sim_start_time = fmi_me_object.sim_start_time
    sim_end_time = fmi_me_object.sim_stop_time
    integration_step_size = fmi_me_object.step_size

    # Create the time-series & results variables and set the initial values
    # Also, initialize the terminate simulation var
    #time_for_result = np.array([sim_start_time])
    time_for_result = [sim_start_time]

    results_data = dict()
    terminate_simulation = list()

    # initialize result arrays for all state vars
    for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():
        for fmu_name, fmu in fmu_map.iteritems():
            fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)
            results_data.update({fmu.name: [fmu_result]})
            terminate_simulation.append(fmu.pyfmi_fmu.get_event_info().terminateSimulation)

    i = 0
    #index_for_result = np.array([i])
    index_for_result = [i]
    time_at_step_i = sim_start_time  # initialize the 'time' variable
    t_next = sim_end_time

    while time_at_step_i < sim_end_time and not True in terminate_simulation:

        # Get the time_increment size
        t_increment = min(integration_step_size, t_next-time_at_step_i)

        # Increment the index and the time
        i += 1
        time_at_step_i = time_at_step_i + t_increment
        
        logger.debug("Solving system for at t={0}".format(time_at_step_i))

        for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():

            this_priority = priority_level

            # Solve all 'this_priority' fmus for this time step
            for fmu_name, fmu in fmu_map.iteritems():

                # Get existing event indicators
                event_indicators = fmu.pyfmi_fmu.get_event_indicators()

                # Get existing states and compute derivatives of the FMU
                x_bar = fmu.pyfmi_fmu.continuous_states
                x_dot = fmu.pyfmi_fmu.get_derivatives()

                # Set time of the FMU
                fmu.pyfmi_fmu.time = time_at_step_i

                # Compute new states and set them
                x_bar = x_bar + t_increment*x_dot
                fmu.pyfmi_fmu.continuous_states = x_bar

                ##########################
                # Get new event indicators
                event_indicators_new = fmu.pyfmi_fmu.get_event_indicators()

                # Inform FMUs of the step and check for a step event (returns True/False)
                step_event = fmu.pyfmi_fmu.completed_integrator_step()

                # Check for time and state events  # time events are 'predictable', state events are not necessarily so.
                time_event  = abs(time_at_step_i-t_next) <= 1.e-10  # this one checks for the end (?)
                state_event = True if True in ((event_indicators_new>0.0) != (event_indicators>0.0)) else False

                # Handle any events
                if step_event or time_event or state_event:

                    event_info = fmu.pyfmi_fmu.get_event_info()
                    event_info.iterationConverged = False

                    # Event iteration
                    while event_info.iterationConverged == False:
                        fmu.pyfmi_fmu.event_update(intermediateResult=True) #Stops after each event iteration
                        event_info = fmu.pyfmi_fmu.get_event_info()

                        #Retrieve solutions (if needed)
                        if event_info.iterationConverged == False:
                            #bouncing_fmu.get_real, get_integer, get_boolean,
                            # get_string(valueref)
                            pass

                    # Check if the event affected the state values and if so sets them
                    if event_info.stateValuesChanged:
                        x_bar = fmu.pyfmi_fmu.continuous_states

                    # Get new nominal values.
                    if event_info.stateValueReferencesChanged:
                        atol = 0.01*rtol*fmu.pyfmi_fmu.nominal_continuous_states

                    # Check for new time event
                    if event_info.upcomingTimeEvent:
                        t_next = min(event_info.nextEventTime, sim_end_time)
                    else:
                        t_next = sim_end_time

                ##########################

                fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)
                result_array = results_data[fmu_name]
                result_array.append(fmu_result)
                # results_data.update({fmu.name: result_array})

            # Propogate values for 'this_priority'
            for conn in fmi_me_object.connections:
                if conn.src_priority == this_priority:
                    src_fmu = fmu_map[conn.src_fmu]
                    conn.src_value_ref = src_fmu.pyfmi_fmu.get_variable_valueref(conn.src_port)
                    value = src_fmu.pyfmi_fmu.get_real(conn.src_value_ref)
                    dst_fmu = fmi_me_object.priority_map[conn.dst_priority][conn.dst_fmu]
                    conn.dst_value_ref = dst_fmu.pyfmi_fmu.get_variable_valueref(conn.dst_port)
                    dst_fmu.pyfmi_fmu.set_real(conn.dst_value_ref, value)

        time_for_result.append(time_at_step_i)
    
    # Save results .csv file
    name_plus_data = ['time'] + time_for_result
    
    with open('results.csv', 'ab') as result_file:
        csv_writer = csv.writer(result_file)
        csv_writer.writerow(name_plus_data)

    #  PLOTTING
    logger.debug("Saving .svg files for all inputs/outputs")   
    
    plot_index = 1

    if not os.path.isdir('Plots'):
        os.mkdir('Plots')

    for priority_level, fmu_map in fmi_me_object.priority_map.iteritems():
        for fmu_name, fmu in fmu_map.iteritems():
            plt.figure(plot_index)
            plt.title(fmu_name)
            plt.xlabel('Time (s)')
            
            # Save all time-varying results to csv
            for value_ref in fmu.time_varying_refs:
                value_ref_index = fmu.time_varying_refs.index(value_ref)
                variable_name = fmu_name + '.' + fmu.pyfmi_fmu.get_variable_by_valueref(value_ref)
                data_series = N.array(results_data[fmu_name])[:,value_ref_index]
                data_series_list = data_series.tolist()
                name_plus_data_series = [variable_name] + data_series_list
                with open('results.csv', 'ab') as result_file:
                    csv_writer = csv.writer(result_file)
                    csv_writer.writerow(name_plus_data_series)
            
            for input_name in fmu.input_names:
                input_valueref = fmu.pyfmi_fmu.get_variable_valueref(input_name)
                var_to_plot_index = fmu.time_varying_refs.index(input_valueref)
                data_series = N.array(results_data[fmu_name])[:,var_to_plot_index]
                plt.plot(time_for_result, data_series, label=input_name)
            for output_name in fmu.output_names:
                output_valueref = fmu.pyfmi_fmu.get_variable_valueref(output_name)
                var_to_plot_index = fmu.time_varying_refs.index(output_valueref)
                data_series = N.array(results_data[fmu_name])[:,var_to_plot_index]
                plt.plot(time_for_result, data_series, label=output_name)

            plt.legend(loc=0)
            plot_name = fmu_name + '_InputsOutputs.svg'
            plot_path = os.path.join('Plots', plot_name)
            plt.savefig(plot_path)
            plt.close()
            plot_index += 1


def main():

    logger.debug("===================================")
    logger.debug("RUNNING jmodelica_model_exchange.py")
    logger.debug("===================================")

    (options, args) = parser.parse_args()

    config_file = r'.\\model_exchange_config.json'

    if options.model_exchange_config_file:
        config_file = options.model_exchange_config_file

    me_config = read_model_exchange_config(config_file)

    fmi_object = FMI_ME(me_config)

    run_explicit_euler(fmi_object)


if __name__ == '__main__':

    root_dir = os.getcwd()

    try:
        main()
    except:
        import traceback
        trace = traceback.format_exc()

        logger.error(trace)
        logger.info('See jmodelica_model_exchange_py.log for details.')
        
        sys.exit(2)
