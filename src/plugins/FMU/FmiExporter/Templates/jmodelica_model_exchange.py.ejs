#
# GENERATED by FmiExporterPlugin (WebGME)
#

__author__ = 'James Klingler - ISIS Vanderbilt'

import os
import sys
import json
import csv
import logging

import matplotlib.pyplot as plt
import numpy as N

from fmi_wrapper import FMI_ME, FMU

try:
    from pymodelica import compile_fmu   # JModelica.org's 'pymodelica'
    from pyfmi import load_fmu
except:
    import_error_msg = "JModelica 'pymodelica' or 'pyfmi' module was not " \
                       "found. Make sure you have set all the environment " \
                       "variables from C:\JModelica.org-1.12\setenv.bat"
    print import_error_msg

# Set up the Option parser
from optparse import OptionParser

parser = OptionParser()
parser.add_option("-c",
                  "--config",
                  dest="model_exchange_config_file",
                  help="Path to the model exchange configuration file.")

                  
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

# Create a file handler with a debug log level
fh = logging.FileHandler("jmodelica_model_exchange_py.log")
fh.setLevel(logging.DEBUG)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.WARNING)

# create formatter and add it to the handlers
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
fh.setFormatter(formatter)
ch.setFormatter(formatter)

# add the handlers to the logger
logger.addHandler(fh)
logger.addHandler(ch)

def read_model_exchange_config(model_exchange_config_file):

    logger.debug("Enter 'read_model_exchange_config({0})'".format(model_exchange_config_file))

    with open(model_exchange_config_file, 'r') as f_in:
        config_dict = json.load(f_in)

    return config_dict
    

def run_explicit_euler(fmi_me_object):

    logger.debug("Enter 'run_explicit_euler'")

    # All FMUs have been loaded and initialized

    sim_start_time = fmi_me_object.sim_start_time
    sim_end_time = fmi_me_object.sim_stop_time
    integration_step_size = fmi_me_object.step_size

    # Create the time-series & results variables and set the initial values
    # Also, initialize the terminate simulation var
    #time_for_result = np.array([sim_start_time])
    time_for_result = [sim_start_time]

    results_data = dict()
    terminate_simulation = list()

    # initialize result arrays for all state variables
    for fmu_path, fmu in fmi_me_object.fmu_map.iteritems():
    
        fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)
        results_data.update({fmu.name: [fmu_result]})
        terminate_simulation.append(fmu.pyfmi_fmu.get_event_info().terminateSimulation)

    i = 0
    #index_for_result = np.array([i])
    index_for_result = [i]
    time_at_step_i = sim_start_time  # initialize the 'time' variable
    t_next = sim_end_time

    while time_at_step_i < sim_end_time and not True in terminate_simulation:

        # Get the time_increment size
        t_increment = min(integration_step_size, t_next-time_at_step_i)

        # Increment the index and the time
        i += 1
        time_at_step_i = time_at_step_i + t_increment
        
        logger.debug("Solving system for at t={0}".format(time_at_step_i))
        
        for i in range(len(fmi_me_object.priority_map)):
           
            fmu_path = fmi_me_object.priority_map[str(i + 1)]
            fmu = fmi_me_object.fmu_map[fmu_path]
            
            logger.debug("Solving {0}".format(fmu.name))

            # Get existing event indicators
            event_indicators = fmu.pyfmi_fmu.get_event_indicators()

            # Get existing states and compute derivatives of the FMU
            x_bar = fmu.pyfmi_fmu.continuous_states
            x_dot = fmu.pyfmi_fmu.get_derivatives()

            # Set time of the FMU
            fmu.pyfmi_fmu.time = time_at_step_i

            # Compute new states and set them
            x_bar = x_bar + t_increment*x_dot
            fmu.pyfmi_fmu.continuous_states = x_bar

            ########### Check for Events ###############
            
            # Get new event indicators
            event_indicators_new = fmu.pyfmi_fmu.get_event_indicators()

            # Inform FMUs of the step and check for a step event (returns True/False)
            step_event = fmu.pyfmi_fmu.completed_integrator_step()

            # Check for time and state events (time events are 'predictable', state events are not necessarily so)
            time_event  = abs(time_at_step_i-t_next) <= 1.e-10  # this one checks for the end (?)
            state_event = True if True in ((event_indicators_new>0.0) != (event_indicators>0.0)) else False

            # Handle any events
            if step_event or time_event or state_event:

                event_info = fmu.pyfmi_fmu.get_event_info()
                event_info.iterationConverged = False

                # Event iteration
                while event_info.iterationConverged == False:
                    fmu.pyfmi_fmu.event_update(intermediateResult=True) #Stops after each event iteration
                    event_info = fmu.pyfmi_fmu.get_event_info()

                    #Retrieve solutions (if needed)
                    if event_info.iterationConverged == False:
                        # fmu.get_real, get_integer, get_boolean,
                        # get_string(valueref)
                        pass

                # Check if the event affected the state values and if so sets them
                if event_info.stateValuesChanged:
                    x_bar = fmu.pyfmi_fmu.continuous_states

                # Get new nominal values.
                if event_info.stateValueReferencesChanged:
                    atol = 0.01*rtol*fmu.pyfmi_fmu.nominal_continuous_states

                # Check for new time event
                if event_info.upcomingTimeEvent:
                    t_next = min(event_info.nextEventTime, sim_end_time)
                else:
                    t_next = sim_end_time

            ##########################

            fmu_result = fmu.pyfmi_fmu.get_real(fmu.time_varying_refs)
            result_array = results_data[fmu.name]
            result_array.append(fmu_result)

            # Propagate output values
            for output_path, output_object in fmu.output_map.iteritems():
                output_value = fmu.pyfmi_fmu.get_real(output_object.value_ref)
            
                if output_path in fmi_me_object.conn_map:
                    for target_input_path in fmi_me_object.conn_map[output_path]:
                        target_fmu_path = get_parent_fmu_path(target_input_path)
                        target_fmu = fmi_me_object.fmu_map[target_fmu_path]
                        input_value_ref = target_fmu.input_map[target_input_path].value_ref
                        target_fmu.pyfmi_fmu.set_real(input_value_ref, output_value)

        time_for_result.append(time_at_step_i)
    
    #  Save results
    logger.debug("Saving .csv and.svg files")   

    save_results(fmi_me_object.fmu_map, time_for_result, results_data)
    
    
def save_results(fmu_map, time_for_result, results_data):

    if not os.path.isdir('Results'):
        os.mkdir('Results')
        
    os.chdir('Results')
    
    name_plus_data = ['time'] + time_for_result
    
    with open('results.csv', 'ab') as result_file:
        csv_writer = csv.writer(result_file)
        csv_writer.writerow(name_plus_data)

    plot_index = 1

    webgme_path_2_plot_path = dict()

    for fmu_path, fmu in fmu_map.iteritems():
    
        plt.figure(plot_index)
        plt.title(fmu.name + ' - Time-changing Variables')
        plt.xlabel('Time (s)')
        plot_index += 1
    
        # Save all time-varying results to csv
        for value_ref in fmu.time_varying_refs:
        
            value_ref_index = fmu.time_varying_refs.index(value_ref)
            variable_name = fmu.pyfmi_fmu.get_variable_by_valueref(value_ref)
            full_name = fmu.name + '.' + variable_name
            data_series = N.array(results_data[fmu.name])[:,value_ref_index]
            data_series_list = data_series.tolist()
            plt.plot(time_for_result, data_series, label=variable_name)
            name_plus_data_series = [full_name] + data_series_list
            with open('results.csv', 'ab') as result_file:
                csv_writer = csv.writer(result_file)
                csv_writer.writerow(name_plus_data_series)

        plt.legend(loc=0)
        plot_name = fmu.name + '_All.svg'
        plt.savefig(plot_name)
        plt.close()
        
        webgme_path_2_plot_path[fmu_path] = plot_name
                
        for webgme_path, input_object in fmu.input_map.iteritems():
        
            plt.figure(plot_index)
            plt.title(input_object.csv_row_header)
            plt.xlabel('Time (s)')
            plot_index += 1
        
            input_valueref = input_object.value_ref
            var_to_plot_index = fmu.time_varying_refs.index(input_valueref)
            data_series = N.array(results_data[fmu.name])[:,var_to_plot_index]
            plt.plot(time_for_result, data_series, label=input_object.name)
            
            plot_name = fmu.name + '_' + input_object.name + '.svg'
            plt.savefig(plot_name)
            plt.close()
            
            webgme_path_2_plot_path[webgme_path] = plot_name
            
        for webgme_path, output_object in fmu.output_map.iteritems():
        
            plt.figure(plot_index)
            plt.title(output_object.csv_row_header)
            plt.xlabel('Time (s)')
            plot_index += 1
        
            output_valueref = output_object.value_ref
            var_to_plot_index = fmu.time_varying_refs.index(output_valueref)
            data_series = N.array(results_data[fmu.name])[:,var_to_plot_index]
            plt.plot(time_for_result, data_series, label=output_object.name)

            plot_name = fmu.name + '_' + output_object.name + '.svg'
            plt.savefig(plot_name)
            plt.close()
            
            webgme_path_2_plot_path[webgme_path] = plot_name
        
    with open('plot_map.json', 'wb') as plot_map_file:
        json.dump(webgme_path_2_plot_path, plot_map_file)
        
    os.chdir('..')
    

def get_parent_fmu_path(fmu_input_path):

    input_split_path = fmu_input_path.split('/')
    parent_split_path = input_split_path[:-1]
    parent_fmu_path = '/'.join(parent_split_path)
    
    return parent_fmu_path
    
            
def main():

    logger.debug("===================================")
    logger.debug("RUNNING jmodelica_model_exchange.py")
    logger.debug("===================================")

    (options, args) = parser.parse_args()

    config_file = r'.\\model_exchange_config.json'

    if options.model_exchange_config_file:
        config_file = options.model_exchange_config_file

    me_config = read_model_exchange_config(config_file)

    fmi_object = FMI_ME(me_config)

    run_explicit_euler(fmi_object)


if __name__ == '__main__':

    root_dir = os.getcwd()

    try:
        main()
    except:
        import traceback
        trace = traceback.format_exc()

        logger.error(trace)
        logger.info('See jmodelica_model_exchange_py.log for details.')
        
        sys.exit(2)
