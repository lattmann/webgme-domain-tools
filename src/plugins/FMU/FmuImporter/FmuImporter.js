/**
* Generated by PluginGenerator from webgme on Mon Apr 28 2014 13:58:17 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
    'plugin/PluginBase',
    'plugin/FmuImporter/FmuImporter/FMU',
    'jszip',
    'xmljsonconverter'], function (PluginConfig, PluginBase, FmuMetaTypes, JSZip, Converter) {
    'use strict';

    /**
    * Initializes a new instance of FmuImporter.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin FmuImporter.
    * @constructor
    */
    var FmuImporter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    FmuImporter.prototype = Object.create(PluginBase.prototype);
    FmuImporter.prototype.constructor = FmuImporter;

    /**
    * Gets the name of the FmuImporter.
    * @returns {string} The name of the plugin.
    * @public
    */
    FmuImporter.prototype.getName = function () {
        return "FMU Model Importer";
    };

    /**
    * Gets the semantic version (semver.org) of the FmuImporter.
    * @returns {string} The version of the plugin.
    * @public
    */
    FmuImporter.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the FmuImporter.
    * @returns {string} The description of the plugin.
    * @public
    */
    FmuImporter.prototype.getDescription = function () {
        return "Creates WebGME models for one or more uploaded FMUs";
    };

    /**
    * Gets the configuration structure for the FmuImporter.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    FmuImporter.prototype.getConfigStructure = function () {
        return [
            {
                "name": "UploadedArtifact",
                "displayName": "FMUs",
                "description": "Click and drag existing compiled FMU(s)",
                "value": "167d532ae62ec4ce73f085fffba2091ac29f487b", // multiple txt.zip in zip
                //"value": "46f9efe35185b3f19cfeeefbf98d22107bbd1b8f", // multiple fmus in zip
                //"value": "0101da04257bf60436b20beb44433b6a45b84e77", // single fmu
                "valueType": "asset",
                "readOnly": false
            }
        ];
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} mainCallback - the result callback
    */
    FmuImporter.prototype.main = function (mainCallback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            selectedNode = self.activeNode,
            fmuLibraryNode,
            currentConfig = self.getCurrentConfig(),
            currentConfigString = JSON.stringify(currentConfig, null, 4),
            artifactHash = currentConfig.UploadedArtifact,
            fmuHash,
            numUploaded,
            numCreated = 0;

        self.logger.debug('Entering FmuImporter main');

        // get all 'possible' object types from the MetaModel
        this.updateMETA(FmuMetaTypes);

        // TODO: Z/P please look at my context checking...
        if (!self.isMetaTypeOf(selectedNode, FmuMetaTypes.FMU_Library)) {
            var msg = "FmuImporter must be called from an FMU_Library!";
            self.logger.error(msg);
            self.createMessage(selectedNode, msg);
            self.result.setSuccess(false);
            mainCallback(msg, self.result);
            return;
        } else {
            fmuLibraryNode = selectedNode;
        }

        self.logger.debug('CurrentConfig:');
        self.logger.debug(currentConfigString);

        var getFmuModelDescriptionsCallback = function (err, hashFmuDescriptionMap) {
            if (err) {
                self.logger.error(err);
                return;
            }

            numUploaded = Object.keys(hashFmuDescriptionMap).length;

            for (fmuHash in hashFmuDescriptionMap) {
                if (self.createNewFmu(fmuLibraryNode, fmuHash, hashFmuDescriptionMap[fmuHash])) {
                    numCreated += 1;
                }
            }

            // This will save the changes. If you don't want to save;
            // exclude self.save and call callback directly from this scope.
            self.result.setSuccess(true);
            self.createMessage(selectedNode, numCreated + " FMUs created out of " + numUploaded + " uploaded.");
            self.save('Saving FmuImporter results to database...', function (err) {
                mainCallback(null, self.result);
            });
        };

        self.getFmuModelDescriptions(artifactHash, getFmuModelDescriptionsCallback);
    };

    FmuImporter.prototype.createNewFmu = function (parentNode, fmuHash, fmuModelDescription, locX, locY) {
        locX = locX || 100;
        locY = locY || 100;

        var self = this,
            newFmuNode,
            newFmuChildNode,
            fmuInfo = fmuModelDescription["fmiModelDescription"],
            modelicaName = fmuInfo["@modelName"],
            fmuName = fmuInfo["@modelIdentifier"],
            splitNames = modelicaName.split('.'),
            modelVariables = fmuInfo["ModelVariables"],
            scalarVariables = modelVariables["ScalarVariable"],
            numVariables = scalarVariables.length,
            variable,
            varName,
            variability,
            causality,
            valueRef,
            description,
            varTypeInfo,
            value,
            i,
            paramX = 400,
            paramY = 100,
            inputX = 100,
            inputY = 100,
            outputX = 700,
            outputY = 100,
            offsetY = 60;

        self.logger.info("Creating " + fmuName);
        // Create the new FMU in current context
        newFmuNode = self.core.createNode({parent: parentNode, base: FmuMetaTypes.FMU});
        self.core.setAttribute(newFmuNode, 'name', fmuName);
        self.core.setAttribute(newFmuNode, 'resource', fmuHash);

        // Create the Inputs, Outputs, Parameters
        for (i = 0; i < numVariables; i += 1) {
            variable = scalarVariables[i];
            varName = variable["@name"];
            variability = variable["@variability"];
            causality = variable["@causality"];
            description = "";
            value = "";
            valueRef = variable["@valueReference"];
            varTypeInfo = self.getVariableTypeInfo(variable);

            if (varName.split('')[0] === '_') {
                continue;  // TODO: revisit this; we might need to make these as properties
            }

            if (variable.hasOwnProperty("@description")) {
                description = variable["@description"];
            }

            if (causality === "input") {

                // Create Input
                newFmuChildNode = self.core.createNode({parent: newFmuNode, base: FmuMetaTypes.Input});
                self.core.setAttribute(newFmuChildNode, 'name', varName);
                self.core.setAttribute(newFmuChildNode, 'description', description);
                self.core.setAttribute(newFmuChildNode, 'fmiValueRef', valueRef);
                self.core.setRegistry(newFmuChildNode, 'position', {x: inputX, y: inputY});
                inputY += offsetY;

            } else if (causality === "output") {

                // Create Output
                newFmuChildNode = self.core.createNode({parent: newFmuNode, base: FmuMetaTypes.Output});
                self.core.setAttribute(newFmuChildNode, 'name', varName);
                self.core.setAttribute(newFmuChildNode, 'description', description);
                self.core.setAttribute(newFmuChildNode, 'fmiValueRef', valueRef);
                self.core.setRegistry(newFmuChildNode, 'position', {x: outputX, y: outputY});
                outputY += offsetY;

            } else if (causality === "internal") {
                if (variability === "parameter") {
                    if (varTypeInfo.hasOwnProperty("@start")) {
                        value = varTypeInfo["@start"]
                    }

                    newFmuChildNode = self.core.createNode({parent: newFmuNode, base: FmuMetaTypes.Parameter});
                    self.core.setAttribute(newFmuChildNode, 'name', varName);
                    self.core.setAttribute(newFmuChildNode, 'value', value);
                    self.core.setAttribute(newFmuChildNode, 'defaultValue', value);
                    self.core.setAttribute(newFmuChildNode, 'description', description);
                    self.core.setAttribute(newFmuChildNode, 'fmiValueRef', valueRef);
                    self.core.setRegistry(newFmuChildNode, 'position', {x: paramX, y: paramY});
                    paramY += offsetY;
                }
            }
        }

        if (newFmuNode) {
            return true;
        } else {
            return false;
        }
    };

    FmuImporter.prototype.getVariableTypeInfo = function (variableDict) {
        var typeInfo = {};

        if (variableDict.hasOwnProperty("Real")) {
            typeInfo = variableDict["Real"];
            typeInfo["_type"] = "Real";
        } else if (variableDict.hasOwnProperty("Boolean")) {
            typeInfo = variableDict["Boolean"];
            typeInfo["_type"] = "Boolean";
        } else if (variableDict.hasOwnProperty("Integer")) {
            typeInfo = variableDict["Integer"];
            typeInfo["_type"] = "Integer";
        } else if (variableDict.hasOwnProperty("Enumeration")) {
            typeInfo = variableDict["Enumeration"];
            typeInfo["_type"] = "Enumeration";
        }

        return typeInfo;
    };

    FmuImporter.prototype.getFmuModelDescriptions = function (uploadedFileHash, callback) {
        var self = this;

        var blobGetMetadataCallback = function (err, metadata) {
            if (err) {
                callback(err);
                return;
            }

            var metadataContent = metadata.content;

            var blobGetObjectCallback = function (err, objectContent) {
                if (err) {
                    callback(err);
                    return;
                }

                var zip,
                    fmuObject,
                    fmuContentName,
                    fmuContent,
                    fmuAsZip,
                    fmuFileHash,
                    modelDescriptionXml,
                    modelDescriptionJson,
                    modelDescriptionMap = {},
                    fmusWithinZip,
                    numFmus,
                    i;

                // TODO: what if the content is not a ZIP? TODO: check metadata
                zip = new JSZip(objectContent);

                modelDescriptionXml = zip.file("modelDescription.xml");

                if (modelDescriptionXml === null) {
                    // we might have a zip with multiple fmus within
                    fmusWithinZip = zip.file(/\.fmu/);
                    numFmus = fmusWithinZip.length;

                    for (i = 0; i < numFmus; i += 1) {
                        fmuObject = fmusWithinZip[i];
                        fmuContentName = fmuObject.name;
                        fmuContent = fmuObject.asArrayBuffer();
                        fmuAsZip = new JSZip(fmuContent);
                        fmuFileHash = metadataContent[fmuContentName].content;  // blob 'soft-link' hash
                        modelDescriptionXml = fmuAsZip.file("modelDescription.xml");
                        if (modelDescriptionXml != null) {
                            modelDescriptionJson = self.convertXml2Json(modelDescriptionXml.asText());
                            modelDescriptionMap[fmuFileHash] = modelDescriptionJson;
                        } else {
                            self.logger.error('Could not extract fmu modelDescription');
                            continue;
                        }
                    }
                } else {
                    modelDescriptionJson = self.convertXml2Json(modelDescriptionXml.asText());
                    modelDescriptionMap[uploadedFileHash] = modelDescriptionJson;
                }

                // return .\modelDescription.xml
                callback(null, modelDescriptionMap);
            };

            self.blobClient.getObject(uploadedFileHash, blobGetObjectCallback);
        };

        self.blobClient.getMetadata(uploadedFileHash, blobGetMetadataCallback);
    };

    FmuImporter.prototype.convertXml2Json = function (modelDescriptionXml) {
        // TODO: what if modelDescriptionXml is NOT an xml?

        var self = this,
            converter = new Converter.Xml2json({skipWSText: true}),
            obj = converter.convertFromStr(modelDescriptionXml);

        return obj;
    };

    /**
     * Finds and returns the node object defining the meta type for the given node.
     * @param node - Node to be check for type.
     * @returns {Object} - Node object defining the meta type of node.
     */
    FmuImporter.prototype.getMetaType = function (node) {
        var self = this,
            name;
        while (node) {
            name = self.core.getAttribute(node, 'name');
            if (self.META.hasOwnProperty(name) && self.core.getPath(self.META[name]) === self.core.getPath(node)) {
                break;
            }
            node = self.core.getBase(node);
        }
        return node;
    };

    /**
     * Checks if the given node is of the given meta-type.
     * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>
     * @param node - Node to be check for type.
     * @param metaTypeObj - Node object defining the meta type.
     * @returns {boolean} - True if the given object was of the META type.
     */
    FmuImporter.prototype.isMetaTypeOf = function (node, metaTypeObj) {
        var self = this;
        while (node) {
            if (self.core.getGuid(node) === self.core.getGuid(metaTypeObj)) {
                return true;
            }
            node = self.core.getBase(node);
        }
        return false;
    };

    return FmuImporter;
});