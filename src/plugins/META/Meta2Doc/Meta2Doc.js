/**
* Generated by PluginGenerator from webgme on Fri Sep 05 2014 15:31:19 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
    'plugin/PluginBase'],
    function (PluginConfig, PluginBase) {
    'use strict';

    /**
    * Initializes a new instance of Meta2Doc.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin Meta2Doc.
    * @constructor
    */
    var Meta2Doc = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.id2MetaNode = {};
        this.id2ElementDoc = {};

        this.LanguageDocumentation = {
            "LanguageElements": {},
            "LanguageElementList": [],
            "LanguageInfo": {
                "Name": null,
                "Version": null,
                "ChangeTime": null,
                "Author": null,
                "Comment": null,
                "Details": {}
            }
        };
    };

    // Prototypal inheritance from PluginBase.
    Meta2Doc.prototype = Object.create(PluginBase.prototype);
    Meta2Doc.prototype.constructor = Meta2Doc;

    /**
    * Gets the name of the Meta2Doc.
    * @returns {string} The name of the plugin.
    * @public
    */
    Meta2Doc.prototype.getName = function () {
        return "Meta2Doc";
    };

    /**
    * Gets the semantic version (semver.org) of the Meta2Doc.
    * @returns {string} The version of the plugin.
    * @public
    */
    Meta2Doc.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the Meta2Doc.
    * @returns {string} The description of the plugin.
    * @public
    */
    Meta2Doc.prototype.getDescription = function () {
        return "Generate Language Documentation from MetaModel";
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    Meta2Doc.prototype.main = function (callback) {
        var self = this;

        self.logger.info("Running Meta2Doc");

        var documentationArtifact = self.blobClient.createArtifact('FMU');

        self.getMetaRelationships();

        var addFileCallbackFunction = function (err, hash) {

            var artifactSaveCallbackFunction = function (err, artifactHash) {
                if (err) {
                    self.result.setSuccess(false);
                    return callback(err, self.result);
                } else {
                    self.result.setSuccess(true);
                    self.result.addArtifact(artifactHash);
                    self.save('added obj', function (err) {
                        callback(null, self.result);
                    });
                }
            };

            documentationArtifact.save(artifactSaveCallbackFunction);
        };

        documentationArtifact.addFile('LanguageElements.json', JSON.stringify(self.LanguageDocumentation), addFileCallbackFunction);
    };

    Meta2Doc.prototype.getMetaRelationships = function () {
        var self = this,
            metaElementName,
            metaElementNode,
            baseClasses;

        for (metaElementName in self.META) {
            if (self.META.hasOwnProperty(metaElementName)) {
                metaElementNode = self.META[metaElementName];
                self.id2MetaNode[self.core.getPath(metaElementNode)] = metaElementNode;
            }
        }

        for (metaElementName in self.META) {
            if (self.META.hasOwnProperty(metaElementName)) {
                metaElementNode = self.META[metaElementName];
                self.createMessage(metaElementNode , metaElementName);

                self.LanguageDocumentation.LanguageElements[metaElementName] = self.makeNewElementDoc(metaElementNode, true);
                self.LanguageDocumentation.LanguageElementList.push(metaElementName);
            }
        }
    };

    Meta2Doc.prototype.makeNewElementDoc = function (metaNode, getDetails) {
        var self = this,
            iterator,
            elementDoc = {
                "Name": null,
                //"DisplayedName": null,
                //"Role": null,
                //"Type": null,
                "GUID": null,
                "ID": null,
                //"Description": null,
                //"Namespace": null,
                "IsAbstract": null,
                "Meta": null,
                //"IsImmediate": null,
                //"Visualization": null,
//                "Attributes": [],
//                "RegistryNames": [],
                "BaseClasses": [],
//                "DerivedClasses": [],
//                "ParentContainerClasses": [],
//                "ChildClasses": [],
//                "ReferredClasses": [],
//                "ReferringClasses": [],
//                "OutgoingConnectionClasses": [],
//                "IncomingConnectionClasses": [],
                "SourceClasses": [],
                "DestinationClasses": []
            };

        if (metaNode != null) {
            elementDoc.Name = self.core.getAttribute(metaNode, 'name');
            elementDoc.ID = self.core.getPath(metaNode);
            elementDoc.GUID = self.core.getGuid(metaNode);
            elementDoc.IsAbstract = self.core.getRegistry(metaNode, 'isAbstract');

            elementDoc.Meta = self.getMeta(metaNode);

            // SourceClasses
            if (elementDoc.Meta.pointers.hasOwnProperty('src')) {
                for (iterator=0;iterator<elementDoc.Meta.pointers['src'].length;iterator++) {
                    elementDoc.SourceClasses.push(self.core.getAttribute(self.id2MetaNode[elementDoc.Meta.pointers['src'][iterator]], 'name'));
                }
            }

            // DestinationClasses
            if (elementDoc.Meta.pointers.hasOwnProperty('dst')) {
                for (iterator=0;iterator<elementDoc.Meta.pointers['dst'].length;iterator++) {
                    elementDoc.DestinationClasses.push(self.core.getAttribute(self.id2MetaNode[elementDoc.Meta.pointers['dst'][iterator]], 'name'));
                }
            }

            if (getDetails) {
                elementDoc.Attributes = self.core.getAttributeNames(metaNode);
                elementDoc.Attributes.sort();
                elementDoc.RegistryNames = self.core.getRegistryNames(metaNode);
                elementDoc.RegistryNames.sort();

                //elementDoc.ParentContainerClasses.push(self.makeNewElementDoc(self.core.getParent(metaNode), false));
                elementDoc.BaseClasses.push(self.makeNewElementDoc(self.core.getBase(metaNode), false));
            }
        }

        return elementDoc;
    };

    Meta2Doc.prototype.makeNewAttributeDoc = function (metaNode) {
        var self = this,
            attributeDoc = {
                "Name": null,
                "Type": null,
                "DefaultValue": null,
                "EnumOptions": null,
                "GUID": null,
                "Description": null,
                "Namespace": null,
                "IsImmediate": null,
                "Help": null
            };

        return attributeDoc;
    };

    Meta2Doc.prototype.getMeta = function (nodeObj){
        var self = this,
            meta = {children:{},attributes:{},pointers:{}},
            node = nodeObj || null;

        if(node){
            var metaNode = self.core.getChild(node,"_meta");
            var childrenNode = self.core.getChild(metaNode,"children");

            //children
            meta.children = self.core.getMemberPaths(childrenNode,"items");

            //attributes - they are simple json objects from our point of view
            var atrNames = self.core.getAttributeNames(metaNode);
            for(var i=0;i<atrNames.length;i++){
                meta.attributes[atrNames[i]] = JSON.parse(JSON.stringify(self.core.getAttribute(metaNode,atrNames[i])));
            }

            //pointers and pointer lists
            var pointerNames = self.core.getPointerNames(metaNode) || [];
            for(var i=0;i<pointerNames.length;i++){
                var pointerNode = self.core.getChild(metaNode,"_p_"+pointerNames[i]);
                meta.pointers[pointerNames[i]] = self.core.getMemberPaths(pointerNode,"items");
            }

            return meta;
        } else {
            return null;
        }
    };

    return Meta2Doc;
});