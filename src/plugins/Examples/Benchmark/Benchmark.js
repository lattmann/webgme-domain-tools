/**
* Generated by PluginGenerator from webgme on Fri Apr 04 2014 13:44:18 GMT-0500 (Central Daylight Time)
*/

define(['plugin/PluginConfig', 'plugin/PluginBase'], function (PluginConfig, PluginBase) {
    'use strict';

    /**
    * Initializes a new instance of Benchmark.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin Benchmark.
    * @constructor
    */
    var Benchmark = function () {
        // Call base class's constructor
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    Benchmark.prototype = Object.create(PluginBase.prototype);
    Benchmark.prototype.constructor = Benchmark;

    /**
    * Gets the name of the Benchmark.
    * @returns {string} The name of the plugin.
    * @public
    */
    Benchmark.prototype.getName = function () {
        return "Benchmark";
    };

    /**
    * Gets the description of the Benchmark.
    * @returns {string} The description of the plugin.
    * @public
    */
    Benchmark.prototype.getVersion = function () {
        return "Description for Benchmark";
    };

    /**
    * Gets the semantic version (semver.org) of the Benchmark.
    * @returns {string} The version of the plugin.
    * @public
    */
    Benchmark.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the configuration structure for the Benchmark.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    Benchmark.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'n',
                'displayName': 'Number of Objects',
                'description': 'How many objects should be created.',
                'value': 10,
                "minValue": 1,
                "maxValue": 10000,
                'valueType': 'number',
                'readOnly': false
            },
            {
                "name": 'metaType',
                'displayName': 'META Type',
                'description': 'Must be allowed to contain itself.',
                'value': 'FCO',
                'valueType': 'string',
                'readOnly': false
            },
            {
                'name': 'save',
                'displayName': 'Save after completion.',
                'description': '',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'create',
                'displayName': 'Create Children',
                'description': '',
                'value': true,
                'valueType': 'boolean',
                'readOnly': false
            },
            {
                'name': 'quiet',
                'displayName': 'Quiet',
                'description': 'To log or not to log.',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            }
        ];
    };

    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always have to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    Benchmark.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            config = this.getCurrentConfig(),
            newNode,
            stats = {config: config},
            i,
            t_stamp = new Date(),
            parent = self.activeNode;


        if (!self.activeNode) {
            callback('Active node not selected.', self.result);
            return;
        }
        self.logger.info(JSON.stringify(config, null, 4));
        // Create n objects.
        if (config.create) {
            for (i = 0; i < config.n; i += 1) {
                newNode = self.core.createNode({parent: parent, base: self.META[config.metaType]});
                self.core.setAttribute(newNode, 'name', 'My new obj');
                self.core.setRegistry(newNode, 'position', {x: 70 + 10 * i, y: 70 + 10 * i});
                if ((i + 1) % 25 === 0) {
                    parent = newNode;
                }
                if (config.quiet === false) {
                    self.logger.info('Created new object!');
                }
            }

            stats.createObjects = (new Date() - t_stamp) / 1000;
        }

        t_stamp = new Date();
        this.objectToVisit = 1; // number of objects that have to be visited
        this.visitedObjects = 0; // number of already visited
        self.core.loadChildren(self.activeNode, function (err, childNodes) {
            self.visitAllChildren(self, childNodes, callback, t_stamp, stats);
        });

    };

    Benchmark.prototype.visitAllChildren = function (self, children, callback, t_stamp, stats) {
        var attrName,
            position,
            i,
            childNode;

        this.objectToVisit += children.length; // all child objects have to be visited

        for (i = 0; i < children.length; i += 1) {
            childNode = children[i];
            attrName = self.core.getAttribute(childNode, 'name');
            position = self.core.getRegistry(childNode, 'position');
            if (!self.getCurrentConfig().quiet) {
                self.logger.info('Found Child ' + attrName + ' : ' + position.toString());
            }
            self.core.loadChildren(childNode, function (err, childNodes) {
                self.visitAllChildren(self, childNodes, callback, t_stamp, stats);
            });
        }

        this.visitedObjects += 1; // another object was just visited

        if (this.objectToVisit === this.visitedObjects) {
            stats.getObjects = (new Date() - t_stamp) / 1000;
            stats.visistedObjects = this.objectToVisit;
            self.logger.info(JSON.stringify(stats, null, 4));
            self.fs.addFile('stat.json', JSON.stringify(stats, null, 4));
            self.fs.saveArtifact();
            self.result.setSuccess(true);
            if (self.getCurrentConfig().save) {
                self.logger.info('Saving project.');
                self.save('added obj', function (err) {
                    callback(null, self.result);
                });
            } else {
                self.logger.info('Closing project without saving.');
                callback(null, self.result);
            }
        }
    };

    return Benchmark;
});