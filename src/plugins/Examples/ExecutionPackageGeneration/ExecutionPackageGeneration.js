/**
* Generated by PluginGenerator from webgme on Wed May 21 2014 11:33:03 GMT-0500 (Central Daylight Time).
*/

define(['plugin/PluginConfig',
    'plugin/PluginBase',
    'ejs',
    'plugin/ExecutionPackageGeneration/ExecutionPackageGeneration/Templates/Templates',
    'executor/ExecutorClient'], function (PluginConfig, PluginBase, ejs, TEMPLATES, ExecutorClient) {
    'use strict';

    /**
    * Initializes a new instance of ExecutionPackageGeneration.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin ExecutionPackageGeneration.
    * @constructor
    */
    var ExecutionPackageGeneration = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    ExecutionPackageGeneration.prototype = Object.create(PluginBase.prototype);
    ExecutionPackageGeneration.prototype.constructor = ExecutionPackageGeneration;

    /**
    * Gets the name of the ExecutionPackageGeneration.
    * @returns {string} The name of the plugin.
    * @public
    */
    ExecutionPackageGeneration.prototype.getName = function () {
        return "Execution Package Generation";
    };

    /**
    * Gets the semantic version (semver.org) of the ExecutionPackageGeneration.
    * @returns {string} The version of the plugin.
    * @public
    */
    ExecutionPackageGeneration.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the description of the ExecutionPackageGeneration.
    * @returns {string} The description of the plugin.
    * @public
    */
    ExecutionPackageGeneration.prototype.getDescription = function () {
        return "Generates an execution package and with configuration file.";
    };

    /**
     * Gets the configuration structure for the ExecutionPackageGeneration.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    ExecutionPackageGeneration.prototype.getConfigStructure = function () {
        return [
            {
                'name': 'allFiles',
                'displayName': 'Return all files',
                'description': 'Should the execution return all files?',
                'value': false,
                'valueType': 'boolean',
                'readOnly': false
            }
        ];
    };
    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    ExecutionPackageGeneration.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            config = self.getCurrentConfig(),
            activeNodePath = self.core.getPath(self.activeNode),
            executor_config = {
                cmd: 'C:/Python27/python.exe ' + 'generate_name.py ' + activeNodePath,
                projectName: self.projectName,
                branchName: self.branchName,
                branchHash: self.branchHash,
                commitHash: self.commitHash,
                currentHash: self.currentHash,
                results: null
            },
            filesToAdd = {
                'generate_name.py': ejs.render(TEMPLATES['generate_name.py.ejs'])
            },
            artifact = self.blobClient.createArtifact('executionFiles');

        if (config.allFiles) {
            executor_config.results = { files: [], dirs: [] };
        } else {
            executor_config.results = {
                files: ['new_name.json'],
                dirs: ['log']
            };
        }
        filesToAdd['executor_config.json'] = JSON.stringify(executor_config, null, 4);
        artifact.addFiles(filesToAdd, function (err) {
            if (err) {
                callback(err, self.result);
                return;
            }
            artifact.save(function (err, hash) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                self.result.addArtifact(hash);
                self.result.setSuccess(true);

                // FIXME: this will work only on client side...
                var executorClient = new ExecutorClient();

                executorClient.createJob(hash, function (err, jobInfo) {
                    // TODO: if err?
                    self.logger.debug(jobInfo);

                    var intervalID = setInterval(function () {
                        executorClient.getInfo(hash, function (err, jInfo) {
                            // TODO: if err?

                            self.logger.info(JSON.stringify(jInfo, null, 4));
                            if (jInfo.status === 'CREATED') {
                                // The job is still running..
                                return;
                            }
                            clearInterval(intervalID);
                            // TODO: check status, failed?
                            if (jInfo.resultHash) {
                                // TODO: assign hash to the model??
                                self.logger.debug(jInfo.resultHash);
                                self.result.addArtifact(jInfo.resultHash);

                            } else {
                                // TODO: check status, failed?

                            }

                            callback(null, self.result);
                        });
                    }, 20);
                });
            });
        });
    };

    return ExecutionPackageGeneration;
});